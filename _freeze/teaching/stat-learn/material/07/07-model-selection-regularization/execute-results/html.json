{
  "hash": "f93bd9089849266c8acf51cb6662288b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Model Selection & Regularization\"\nauthor: \"Termeh Shafie\"\nformat:\n  html:\n    embed-resources: true\nnumber-sections: true\ntoc: true         \neditor: visual\nexecute:\n  cache:  true\n---\n\n# Regularization\nNow that we know how to use model validation to check for overfitting, we might want to help *fix* overfitting. We do this with **regularization** which helps take a model thats to the righthand side of our Bias Variance graph and move it towards the center by making our model *simpler*. \n\nOne way we can do that is by *penalizing* the coefficients of our model if they're too large in magnitude (far away from 0 in either direction). \n\n## LASSO\nLASSO penalizes the sum of the *absolute value* of the coefficients by adding a penalty term to the loss function:\n\n$$ \\underbrace{\\text{RSS}}_{\\sum(x_i - \\hat{x_i})^2} + \\lambda \\sum | \\beta_i |$$\n\nLASSO has the benefit of tending to drag coefficients that don't \"pull their weight\" to *exactly* 0, thus removing them from the model.\n\n\n## Ridge\nRidge penalizes the sum of the *squared* coefficients by adding a penalty term to the loss function:\n\n$$ \\underbrace{\\text{RSS}}_{\\sum(x_i - \\hat{x_i})^2} + \\lambda \\sum  \\beta_i^2$$\n\nUnlike LASSO, Ridge tends to drag coefficients that don't \"pull their weight\" to *near* 0, thus NOT removing them from the model.\n\n\n## Penalties in General\nBoth models create a tug-of-war where coefficients ($\\beta_i$) need to \"pull their weight\" by reducing the Sum of Squared Residuals ($\\text{RSS}$) in order to be \"worth\" having a large value in the penalty. \n\nThe hyperparameter $\\lambda$ controls how *much* coefficients are penalized. \n\n### *Question*\nIf $\\lambda = 0$, what happens to our model?\n\n\n## Alternative Regularization Explanation\n\nYou can also think of Ridge and LASSO as having a \"budget\" for how big the sum of your (squared or absolute valued) coefficients can be.\n\n<img src=\"https://drive.google.com/uc?export=view&id=1y_GJ-Y7t2sYU_gVSkJjlYWnnoZmHcTQk\" width = \"600\"/>\n\nThis graph shows the concept of LASSO and RIDGE in a simple 2-parameter situation. The teal/blue circle (right) and square (left) represent the values for $\\beta_1$ and $\\beta_2$ that satisfy the \"budget\" for our coefficients. The dot in the middle of the red rings represents what the coefficients would be if we did not add a penalty at all. As you move from the inner to the outer red rings, the Residual Sums of Squares (RSS) goes up, meaning that our model is worse at accurately predicting data in our sample (remember that we're giving up accuracy in the *current* sample, to hopefully gain accuracy out-of-sample).\n\nYou can see that the coefficients chosen by LASSO/Ridge occur at the point of the teal/blue area that meets the red rings. This is because 1) when we penalize our model, it HAS to fit within the contraints we give it (the teal/blue area) but 2) we still want the RSS to be as small as possible (a model that's bad on ALL data sets isn't useful).\n\n## How to choose between LASSO and Ridge?\n\nIn general: if you want to do variable selection (i.e. completely remove some variables), choose LASSO. But in the real world, people often use something called Elastic Net, which adds both LASSO (L1) *and* Ridge (L2) penalties to the loss function (see [here](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.ElasticNetCV.html)).\n\n# Ridge and LASSO in R\nWe apply both Ridge and LASSO to the Amazon book data set from before.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages needed\nlibrary(tidyverse)\nlibrary(glmnet)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(broom)\nlibrary(patchwork)\nlibrary(leaps) # install if not on your machine\nlibrary(ISLR2) # data used from book package\n```\n:::\n\n\n\n\nNote, when using `glmnet`, the alpha argument determines the penalty term:\n\n- If alpha = 0: pure ridge\n- If alpha = 1: pure lasso\n- If alpha = 0.5: half ridge + half lasso\n\n\n## LASSO\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---- Load & clean data ----\nama <- read_tsv(\"07-data/amazon-books.txt\") |>\n  drop_na()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 325 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (5): Title, Author, Hard/ Paper, Publisher, ISBN-10\ndbl (8): List Price, Amazon Price, NumPages, Pub year, Height, Width, Thick,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(ama) <- c(\n  \"Title\", \"Author\", \"List.Price\", \"Amazon.Price\", \"Hard.Paper\",\n  \"NumPages\", \"Publisher\", \"Pub.year\", \"ISBN.10\",\n  \"Height\", \"Width\", \"Thick\", \"Weight.oz\"\n)\n\n# ---- Set up X and y ----\npredictors <- c(\"List.Price\", \"NumPages\", \"Weight.oz\", \"Thick\", \"Height\", \"Width\")\n\nX <- ama[, predictors]\ny <- ama$Amazon.Price\n\n# ---- Train/Test Split (80/20) ----\nset.seed(12345)\n\nn <- nrow(ama)\ntrain_idx <- sample(seq_len(n), size = floor(0.8 * n))\n\nX_train <- X[train_idx, ]\nX_test  <- X[-train_idx, ]\ny_train <- y[train_idx]\ny_test  <- y[-train_idx]\n\n# Model matrices (glmnet will standardize internally)\nX_train_mm <- model.matrix(~ . - 1, data = X_train)\nX_test_mm  <- model.matrix(~ . - 1, data = X_test)\n\n# ---- Lasso with Cross-Validation (alpha = 1) ----\ncv_fit <- cv.glmnet(\n  x = X_train_mm,\n  y = y_train,\n  alpha = 1,          # Lasso\n  standardize = TRUE  # default; explicit for clarity\n)\n\n# ---- Predict ----\ny_pred_train <- as.numeric(predict(cv_fit, newx = X_train_mm, s = \"lambda.min\"))\ny_pred_test  <- as.numeric(predict(cv_fit, newx = X_test_mm,  s = \"lambda.min\"))\n\n# ---- Metrics ----\nmse  <- function(y, yhat) mean((y - yhat)^2)\nmae  <- function(y, yhat) mean(abs(y - yhat))\nmape <- function(y, yhat) mean(abs((y - yhat) / y)) * 100\nr2   <- function(y, yhat) 1 - sum((y - yhat)^2) / sum((y - mean(y))^2)\n\n# ---- Summary ----\nresultsL <- data.frame(\n  Dataset = c(\"Train\", \"Test\"),\n  MSE  = c(mse(y_train, y_pred_train),\n           mse(y_test,  y_pred_test)),\n  MAE  = c(mae(y_train, y_pred_train),\n           mae(y_test,  y_pred_test)),\n  MAPE = c(mape(y_train, y_pred_train),\n           mape(y_test,  y_pred_test)),\n  R2   = c(r2(y_train, y_pred_train),\n           r2(y_test,  y_pred_test))\n)\n\n# ---- Pretty Table ----\nresultsL |>\n  kable(digits = 4, align = \"c\",\n        caption = \"LASSO Regression Performance Summary\") |>\n  kable_styling(full_width = FALSE, bootstrap_options = c(\"striped\", \"hover\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>LASSO Regression Performance Summary</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> Dataset </th>\n   <th style=\"text-align:center;\"> MSE </th>\n   <th style=\"text-align:center;\"> MAE </th>\n   <th style=\"text-align:center;\"> MAPE </th>\n   <th style=\"text-align:center;\"> R2 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> Train </td>\n   <td style=\"text-align:center;\"> 12.0562 </td>\n   <td style=\"text-align:center;\"> 2.3216 </td>\n   <td style=\"text-align:center;\"> 20.4430 </td>\n   <td style=\"text-align:center;\"> 0.9259 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> Test </td>\n   <td style=\"text-align:center;\"> 5.3945 </td>\n   <td style=\"text-align:center;\"> 1.7597 </td>\n   <td style=\"text-align:center;\"> 18.1162 </td>\n   <td style=\"text-align:center;\"> 0.6238 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n## Ridge\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---- Train/Test Split (80/20) ----\nset.seed(12345)  # use same seed as LASSO if you want identical split\n\nn <- nrow(ama)\ntrain_idx <- sample(seq_len(n), size = floor(0.8 * n))\n\nX_train <- X[train_idx, ]\nX_test  <- X[-train_idx, ]\ny_train <- y[train_idx]\ny_test  <- y[-train_idx]\n\n# Model matrices (glmnet will standardize internally)\nX_train_mm <- model.matrix(~ . - 1, data = X_train)\nX_test_mm  <- model.matrix(~ . - 1, data = X_test)\n\n# ---- Ridge with Cross-Validation (alpha = 0) ----\ncv_ridge <- cv.glmnet(\n  x = X_train_mm,\n  y = y_train,\n  alpha = 0,          # Ridge\n  standardize = TRUE  # default; explicit for clarity\n)\n\n# ---- Predict ----\ny_pred_train <- as.numeric(predict(cv_ridge, newx = X_train_mm, s = \"lambda.min\"))\ny_pred_test  <- as.numeric(predict(cv_ridge, newx = X_test_mm,  s = \"lambda.min\"))\n\n# ---- Metrics ----\nmse  <- function(y, yhat) mean((y - yhat)^2)\nmae  <- function(y, yhat) mean(abs(y - yhat))\nmape <- function(y, yhat) mean(abs((y - yhat) / y)) * 100\nr2   <- function(y, yhat) 1 - sum((y - yhat)^2) / sum((y - mean(y))^2)\n\nresultsR <- data.frame(\n  Dataset = c(\"Train\", \"Test\"),\n  MSE  = c(mse(y_train, y_pred_train),\n           mse(y_test,  y_pred_test)),\n  MAE  = c(mae(y_train, y_pred_train),\n           mae(y_test,  y_pred_test)),\n  MAPE = c(mape(y_train, y_pred_train),\n           mape(y_test,  y_pred_test)),\n  R2   = c(r2(y_train, y_pred_train),\n           r2(y_test,  y_pred_test))\n)\n\n# ---- Pretty Table ----\nresultsR |>\n  kable(digits = 4, align = \"c\",\n        caption = \"Ridge Regression Performance Summary\") |>\n  kable_styling(full_width = FALSE, bootstrap_options = c(\"striped\", \"hover\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Ridge Regression Performance Summary</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> Dataset </th>\n   <th style=\"text-align:center;\"> MSE </th>\n   <th style=\"text-align:center;\"> MAE </th>\n   <th style=\"text-align:center;\"> MAPE </th>\n   <th style=\"text-align:center;\"> R2 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> Train </td>\n   <td style=\"text-align:center;\"> 13.5612 </td>\n   <td style=\"text-align:center;\"> 2.2791 </td>\n   <td style=\"text-align:center;\"> 19.8514 </td>\n   <td style=\"text-align:center;\"> 0.9166 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> Test </td>\n   <td style=\"text-align:center;\"> 4.9377 </td>\n   <td style=\"text-align:center;\"> 1.7572 </td>\n   <td style=\"text-align:center;\"> 20.6326 </td>\n   <td style=\"text-align:center;\"> 0.6557 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n### Question\nInterpret the results from LASSO and Rdige Regression.\n\n\n::: {.callout-tip collapse=\"true\"}\n### Answer\n- Ridge Regression shows better test performance than LASSO, with a **lower Test MSE** (4.94 vs 5.39) and **higher Test R²** (0.656 vs 0.624).  \n- **LASSO** fits the training data slightly better, but this advantage does not translate into improved test accuracy.  \n- The similarity in **MAE** and **MAPE** across models indicates both methods capture overall price patterns comparably.  \n- The stronger generalization of Ridge suggests that, for this dataset, **Ridge is the preferred regularization method**, producing more stable estimates without overshrinking important predictors. In other words, Ridge generalizes slightly better than LASSO on this dataset. Ridge has lower Test MSE (4.94 vs 5.39) and higher Test R² (0.656 vs 0.624).\n:::\n\n\n## Plotting Regularization Paths\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit models\nridge_fit <- glmnet(X, y, alpha = 0)\nlasso_fit <- glmnet(X, y, alpha = 1)\n\n# Convert glmnet output to long data frame \nextract_paths <- function(fit, model_name) {\n  coefs <- as.matrix(fit$beta)   # p x K (rows = features, cols = lambdas)\n  lambdas <- fit$lambda          # length K\n  \n  # transpose so rows = lambdas, cols = features\n  df <- as.data.frame(t(coefs))  # now nrow = length(lambda), ncol = p\n  \n  df$lambda <- lambdas\n  df$model <- model_name\n  \n  df_long <- df %>%\n    tidyr::pivot_longer(\n      cols = -c(lambda, model),\n      names_to = \"term\",\n      values_to = \"estimate\"\n    ) %>%\n    dplyr::mutate(log_lambda = log(lambda))\n  \n  df_long\n}\n\nridge_df <- extract_paths(ridge_fit, \"Ridge\")\nlasso_df <- extract_paths(lasso_fit, \"Lasso\")\n\npaths <- bind_rows(ridge_df, lasso_df)\n\n# Ridge plot\ng_ridge <- paths %>%\n  filter(model == \"Ridge\") %>%\n  ggplot(aes(x = log_lambda, y = estimate, color = term)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Ridge Regularization Paths\",\n       x = \"log(lambda)\", y = \"Coefficient\") +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\")\n\n# Lasso plot\ng_lasso <- paths %>%\n  filter(model == \"Lasso\") %>%\n  ggplot(aes(x = log_lambda, y = estimate, color = term)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Lasso Regularization Paths\",\n       x = \"log(lambda)\", y = \"Coefficient\") +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\")\n\n\n# now let's put norms as x axes\npaths_norm <- paths %>%\n  group_by(model, lambda) %>%\n  mutate(\n    l1_norm = sum(abs(estimate)),            # For Lasso\n    l2_norm = sqrt(sum(estimate^2))          # For Ridge\n  ) %>%\n  ungroup()\n\ng_ridgenorms <- paths_norm %>%\n  filter(model == \"Ridge\") %>%\n  ggplot(aes(x = l2_norm, y = estimate, color = term)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Ridge Regularization Paths\",\n       x = \"L2 Norm of Coefficients\", y = \"Coefficient\") +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\")\n\ng_lassonorms <- paths_norm %>%\n  filter(model == \"Lasso\") %>%\n  ggplot(aes(x = l1_norm, y = estimate, color = term)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Lasso Regularization Paths\",\n       x = \"L1 Norm of Coefficients\", y = \"Coefficient\") +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"bottom\")\n\n\n# Combine all\n(g_ridge + g_lasso) / (g_ridgenorms + g_lassonorms)\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/plot-reg-1.png){width=960}\n:::\n:::\n\n\nNote that we can use `glmnet()` to plot these regularizations plots directly, we do this in the next part. However, the x axis will then look slightly different as `glmnet()` uses norms as x axes, making the plot independent of the specific $\\lambda$ scale.\n\nAlso note that in the above plot, each model is using its own $\\lambda$ sequence generated by `glmnet()`, so:\n\n- Ridge might use $\\lambda$ from $0.1 \\rightarrow 10^4$\n- Lasso might use $\\lambda$ from $10^{-4} \\rightarrow 10^2$\n\nThis is because ridge and lasso get different grids, leading to different x-axis ranges. You can of course set the same grid for both which we do in the next part.\n\n# Classwork: Linear Models and Regularization Methods (from ISLR2)\n\n## Subset Selection Methods\n\n### Best Subset Selection\nHere we apply the best subset selection approach to the `Hitters` data from the `ISLR2` package. We wish to predict a baseball player's `Salary` on the basis of various statistics associated with performance in the previous year.\n\nFirst of all, we note that the `Salary` variable is missing for some of the players. The `is.na()` function can be used to identify the missing observations. It returns a vector of the same length as the input vector, with a `TRUE` for any elements that are missing, and a `FALSE` for non-missing elements. The `sum()` function can then be used to count all of the missing elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(Hitters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"AtBat\"     \"Hits\"      \"HmRun\"     \"Runs\"      \"RBI\"       \"Walks\"    \n [7] \"Years\"     \"CAtBat\"    \"CHits\"     \"CHmRun\"    \"CRuns\"     \"CRBI\"     \n[13] \"CWalks\"    \"League\"    \"Division\"  \"PutOuts\"   \"Assists\"   \"Errors\"   \n[19] \"Salary\"    \"NewLeague\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(Hitters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 322  20\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(is.na(Hitters$Salary))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 59\n```\n\n\n:::\n:::\n\nHence we see that `Salary` is missing for $59$ players. The `na.omit()` function removes all of the rows that have missing values in any variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHitters <- na.omit(Hitters)\ndim(Hitters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 263  20\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(is.na(Hitters))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\nThe `regsubsets()` function (part of the `leaps` library) performs best subset selection by identifying the best model that contains a given number of predictors, where *best* is quantified using RSS. The syntax is the same as for `lm()`. The `summary()` command outputs the best set of variables for each model size.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregfit.full <- regsubsets(Salary ~ ., Hitters)\nsummary(regfit.full)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSubset selection object\nCall: regsubsets.formula(Salary ~ ., Hitters)\n19 Variables  (and intercept)\n           Forced in Forced out\nAtBat          FALSE      FALSE\nHits           FALSE      FALSE\nHmRun          FALSE      FALSE\nRuns           FALSE      FALSE\nRBI            FALSE      FALSE\nWalks          FALSE      FALSE\nYears          FALSE      FALSE\nCAtBat         FALSE      FALSE\nCHits          FALSE      FALSE\nCHmRun         FALSE      FALSE\nCRuns          FALSE      FALSE\nCRBI           FALSE      FALSE\nCWalks         FALSE      FALSE\nLeagueN        FALSE      FALSE\nDivisionW      FALSE      FALSE\nPutOuts        FALSE      FALSE\nAssists        FALSE      FALSE\nErrors         FALSE      FALSE\nNewLeagueN     FALSE      FALSE\n1 subsets of each size up to 8\nSelection Algorithm: exhaustive\n         AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI\n1  ( 1 ) \" \"   \" \"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n2  ( 1 ) \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n3  ( 1 ) \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n4  ( 1 ) \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n5  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n6  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n7  ( 1 ) \" \"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \"*\"   \"*\"    \" \"   \" \" \n8  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \"*\"    \"*\"   \" \" \n         CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN\n1  ( 1 ) \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n2  ( 1 ) \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n3  ( 1 ) \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n4  ( 1 ) \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n5  ( 1 ) \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n6  ( 1 ) \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n7  ( 1 ) \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n8  ( 1 ) \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n```\n\n\n:::\n:::\n\n\nAn asterisk indicates that a given variable is included in the corresponding model. For instance, this output indicates that the best two-variable model contains only `Hits` and `CRBI`. By default, `regsubsets()` only reports results up to the best eight-variable model. But the `nvmax` option can be used in order to return as many variables as are desired. Here we fit up to a 19-variable model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregfit.full <- regsubsets(Salary ~ ., data = Hitters,\n    nvmax = 19)\nreg.summary <- summary(regfit.full)\n```\n:::\n\n\nThe `summary()` function also returns $R^2$, RSS, adjusted $R^2$, $C_p$, and BIC. We can examine these to try to select the *best* overall model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(reg.summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"which\"  \"rsq\"    \"rss\"    \"adjr2\"  \"cp\"     \"bic\"    \"outmat\" \"obj\"   \n```\n\n\n:::\n:::\n\n\nFor instance, we see that the $R^2$ statistic increases from $32 \\%$, when only one variable is included in the model, to almost $55 \\%$, when all variables are included. As expected, the $R^2$ statistic increases monotonically as more variables are included.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg.summary$rsq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.3214501 0.4252237 0.4514294 0.4754067 0.4908036 0.5087146 0.5141227\n [8] 0.5285569 0.5346124 0.5404950 0.5426153 0.5436302 0.5444570 0.5452164\n[15] 0.5454692 0.5457656 0.5459518 0.5460945 0.5461159\n```\n\n\n:::\n:::\n\n\nPlotting RSS, adjusted $R^2$, $C_p$, and BIC for all of the models at once will help us decide which model to select.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf = data.frame(adjR2 = reg.summary$adjr2,\n                rss = reg.summary$rss,\n                Cp = reg.summary$cp,\n                BIC = reg.summary$bic,\n                Variables = seq(1:19))\ndf_long = df %>%\n  pivot_longer(cols = c(adjR2, rss, Cp, BIC),\n               names_to = \"Metric\",\n               values_to = \"Value\")\n\ndf_long %>%\n  ggplot(aes(x = Variables, y = Value)) +\n  geom_line() +\n  facet_wrap(~Metric, scales = \"free_y\") + \n  labs(x = \"Number of Variables\", y = \"Value\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/plot-sumstats-1.png){width=672}\n:::\n:::\n\n\nThe `which.max()` function can be used to identify the location of the maximum point of a vector. We will now plot a red dot to indicate the model with the largest adjusted $R^2$ statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_index <- which.max(df$adjR2)\n\ndf %>%\n  ggplot(aes(x = Variables, y = adjR2)) +\n  geom_line() + \n  geom_point(aes(x = max_index, y = adjR2[max_index]),\n             color = \"red\", size = 4, shape = 20) + \n  labs(x = \"Number of Variables\", y = \"Adjusted R²\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/max-r2-1.png){width=672}\n:::\n:::\n\n\nIn a similar fashion we can plot the $C_p$ and BIC statistics, and indicate the models with the smallest statistic using `which.min()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_cp <- which.min(df$Cp)\nmin_bic <- which.min(df$BIC)\n\ndf %>%\n  ggplot(aes(x = Variables, y = Cp)) +\n  geom_line() + \n  geom_point(aes(x = min_cp, y = Cp[min_cp]),\n             color = \"red\", size = 4, shape = 20) + \n  labs(x = \"Number of Variables\", y = \"Cp\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/C_p-BIC-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndf %>%\n  ggplot(aes(x = Variables, y = BIC)) +\n  geom_line() + \n  geom_point(aes(x = min_bic, y = BIC[min_bic]),\n             color = \"red\", size = 4, shape = 20) + \n  labs(x = \"Number of Variables\", y = \"BIC\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/C_p-BIC-2.png){width=672}\n:::\n:::\n\n\nThe `regsubsets()` function has a built-in `plot()` command which can be used to display the selected variables for the best model with a given number of predictors, ranked according to the BIC, $C_p$, adjusted $R^2$, or AIC. To find out more about this function, type `?plot.regsubsets`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(regfit.full, scale = \"r2\")\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/plot-all-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(regfit.full, scale = \"adjr2\")\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/plot-all-2.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(regfit.full, scale = \"Cp\")\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/plot-all-3.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(regfit.full, scale = \"bic\")\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/plot-all-4.png){width=672}\n:::\n:::\n\n\nThe top row of each plot contains a black square for each variable selected according to the optimal model associated with that statistic. For instance, we see that several models share a BIC close to $-150$. However, the model with the lowest BIC is the six-variable model that contains only `AtBat`, `Hits`, `Walks`, `CRBI`, `DivisionW`, and `PutOuts`. We can use the `coef()` function to see the coefficient estimates associated with this model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(regfit.full, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)        AtBat         Hits        Walks         CRBI    DivisionW \n  91.5117981   -1.8685892    7.6043976    3.6976468    0.6430169 -122.9515338 \n     PutOuts \n   0.2643076 \n```\n\n\n:::\n:::\n\n\n### Forward and Backward Stepwise Selection\n\nWe can also use the `regsubsets()` function to perform forward stepwise or backward stepwise selection, using the argument `method = \"forward\"` or `method = \"backward\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregfit.fwd <- regsubsets(Salary ~ ., data = Hitters,\n                         nvmax = 19, method = \"forward\")\nsummary(regfit.fwd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSubset selection object\nCall: regsubsets.formula(Salary ~ ., data = Hitters, nvmax = 19, method = \"forward\")\n19 Variables  (and intercept)\n           Forced in Forced out\nAtBat          FALSE      FALSE\nHits           FALSE      FALSE\nHmRun          FALSE      FALSE\nRuns           FALSE      FALSE\nRBI            FALSE      FALSE\nWalks          FALSE      FALSE\nYears          FALSE      FALSE\nCAtBat         FALSE      FALSE\nCHits          FALSE      FALSE\nCHmRun         FALSE      FALSE\nCRuns          FALSE      FALSE\nCRBI           FALSE      FALSE\nCWalks         FALSE      FALSE\nLeagueN        FALSE      FALSE\nDivisionW      FALSE      FALSE\nPutOuts        FALSE      FALSE\nAssists        FALSE      FALSE\nErrors         FALSE      FALSE\nNewLeagueN     FALSE      FALSE\n1 subsets of each size up to 19\nSelection Algorithm: forward\n          AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI\n1  ( 1 )  \" \"   \" \"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n2  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n3  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n4  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n5  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n6  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n7  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n8  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \"*\" \n9  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n10  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n11  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n12  ( 1 ) \"*\"   \"*\"  \" \"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n13  ( 1 ) \"*\"   \"*\"  \" \"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n14  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n15  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n16  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n17  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n18  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \"*\"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n19  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \"*\"   \"*\"    \"*\"   \"*\"    \"*\"   \"*\" \n          CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN\n1  ( 1 )  \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n2  ( 1 )  \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n3  ( 1 )  \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n4  ( 1 )  \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n5  ( 1 )  \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n6  ( 1 )  \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n7  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n8  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n9  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n10  ( 1 ) \"*\"    \" \"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n11  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n12  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n13  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n14  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n15  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n16  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n17  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n18  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n19  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n```\n\n\n:::\n\n```{.r .cell-code}\nregfit.bwd <- regsubsets(Salary ~ ., data = Hitters,\n                         nvmax = 19, method = \"backward\")\nsummary(regfit.bwd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSubset selection object\nCall: regsubsets.formula(Salary ~ ., data = Hitters, nvmax = 19, method = \"backward\")\n19 Variables  (and intercept)\n           Forced in Forced out\nAtBat          FALSE      FALSE\nHits           FALSE      FALSE\nHmRun          FALSE      FALSE\nRuns           FALSE      FALSE\nRBI            FALSE      FALSE\nWalks          FALSE      FALSE\nYears          FALSE      FALSE\nCAtBat         FALSE      FALSE\nCHits          FALSE      FALSE\nCHmRun         FALSE      FALSE\nCRuns          FALSE      FALSE\nCRBI           FALSE      FALSE\nCWalks         FALSE      FALSE\nLeagueN        FALSE      FALSE\nDivisionW      FALSE      FALSE\nPutOuts        FALSE      FALSE\nAssists        FALSE      FALSE\nErrors         FALSE      FALSE\nNewLeagueN     FALSE      FALSE\n1 subsets of each size up to 19\nSelection Algorithm: backward\n          AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI\n1  ( 1 )  \" \"   \" \"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n2  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n3  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n4  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n5  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n6  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n7  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n8  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \"*\" \n9  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n10  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n11  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n12  ( 1 ) \"*\"   \"*\"  \" \"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n13  ( 1 ) \"*\"   \"*\"  \" \"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n14  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n15  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n16  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n17  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n18  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \"*\"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n19  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \"*\"   \"*\"    \"*\"   \"*\"    \"*\"   \"*\" \n          CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN\n1  ( 1 )  \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n2  ( 1 )  \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n3  ( 1 )  \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n4  ( 1 )  \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n5  ( 1 )  \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n6  ( 1 )  \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n7  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n8  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n9  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n10  ( 1 ) \"*\"    \" \"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n11  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n12  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n13  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n14  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n15  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n16  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n17  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n18  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n19  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n```\n\n\n:::\n:::\n\n\nFor instance, we see that using forward stepwise selection, the best one-variable model contains only `CRBI`, and the best two-variable model additionally includes `Hits`. For this data, the best one-variable through six-variable models are each identical for best subset and forward selection. However, the best seven-variable models identified by forward stepwise selection, backward stepwise selection, and best subset selection are different.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(regfit.full, 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)         Hits        Walks       CAtBat        CHits       CHmRun \n  79.4509472    1.2833513    3.2274264   -0.3752350    1.4957073    1.4420538 \n   DivisionW      PutOuts \n-129.9866432    0.2366813 \n```\n\n\n:::\n\n```{.r .cell-code}\ncoef(regfit.fwd, 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)        AtBat         Hits        Walks         CRBI       CWalks \n 109.7873062   -1.9588851    7.4498772    4.9131401    0.8537622   -0.3053070 \n   DivisionW      PutOuts \n-127.1223928    0.2533404 \n```\n\n\n:::\n\n```{.r .cell-code}\ncoef(regfit.bwd, 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)        AtBat         Hits        Walks        CRuns       CWalks \n 105.6487488   -1.9762838    6.7574914    6.0558691    1.1293095   -0.7163346 \n   DivisionW      PutOuts \n-116.1692169    0.3028847 \n```\n\n\n:::\n:::\n\n\n### Choosing Among Models Using the Validation-Set Approach and Cross-Validation\n\nWe just saw that it is possible to choose among a set of models of different sizes using $C_p$, BIC, and adjusted $R^2$. We will now consider how to do this using the validation set and cross-validation approaches.\n\nIn order for these approaches to yield accurate estimates of the test error, we must use *only the training observations* to perform all aspects of model-fitting---including variable selection. Therefore, the determination of which model of a given size is best must be made using *only the training observations*. This point is subtle but important. If the full data set is used to perform the best subset selection step, the validation set errors and cross-validation errors that we obtain will not be accurate estimates of the test error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\ntrain <- sample(c(TRUE, FALSE),\n                nrow(Hitters),\n                replace = TRUE)\n\ntest <- (!train)\n```\n:::\n\n\nNow, we apply `regsubsets()` to the training set in order to perform best subset selection.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregfit.best <- regsubsets(Salary ~ .,\n                          data = Hitters[train, ],\n                          nvmax = 19)\n```\n:::\n\n\nNotice that we subset the `Hitters` data frame directly in the call in order to access only the training subset of the data, using the expression `Hitters[train, ]`. We now compute the validation set error for the best model of each model size. We first make a model matrix from the test data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest.mat <- model.matrix(Salary ~ ., data = Hitters[test, ])\n```\n:::\n\n\nThe `model.matrix()` function is used in many regression packages for building an \"X\" matrix from data. Now we run a loop, and for each size `i`, we extract the coefficients from `regfit.best` for the best model of that size, multiply them into the appropriate columns of the test model matrix to form the predictions, and compute the test MSE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nval.errors <- rep(NA, 19)\nfor (i in 1:19) {\n coefi <- coef(regfit.best, id = i)\n pred <- test.mat[, names(coefi)] %*% coefi\n val.errors[i] <- mean((Hitters$Salary[test] - pred)^2)\n}\n```\n:::\n\n\nWe find that the best model is the one that contains seven variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nval.errors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 164377.3 144405.5 152175.7 145198.4 137902.1 139175.7 126849.0 136191.4\n [9] 132889.6 135434.9 136963.3 140694.9 140690.9 141951.2 141508.2 142164.4\n[17] 141767.4 142339.6 142238.2\n```\n\n\n:::\n\n```{.r .cell-code}\nwhich.min(val.errors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\ncoef(regfit.best, 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)        AtBat         Hits        Walks        CRuns       CWalks \n  67.1085369   -2.1462987    7.0149547    8.0716640    1.2425113   -0.8337844 \n   DivisionW      PutOuts \n-118.4364998    0.2526925 \n```\n\n\n:::\n:::\n\n\nThis was a little tedious, partly because there is no `predict()` method for `regsubsets()`. Since we will be using this function again, we can capture our steps above and write our own predict method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n predict.regsubsets <- function(object, newdata, id, ...) {\n  form <- as.formula(object$call[[2]])\n  mat <- model.matrix(form, newdata)\n  coefi <- coef(object, id = id)\n  xvars <- names(coefi)\n  mat[, xvars] %*% coefi\n }\n```\n:::\n\n\nOur function pretty much mimics what we did above. The only complex part is how we extracted the formula used in the call to `regsubsets()`. We demonstrate how we use this function below, when we do cross-validation.\n\nFinally, we perform best subset selection on the full data set, and select the best seven-variable model. It is important that we make use of the full data set in order to obtain more accurate coefficient estimates.\n\nNote that we perform best subset selection on the full data set and select the best seven-variable model, rather than simply using the variables that were obtained from the training set, because the best seven-variable model on the full data set may differ from the corresponding model on the training set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregfit.best <- regsubsets(Salary ~ ., data = Hitters,\n    nvmax = 19)\ncoef(regfit.best, 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)         Hits        Walks       CAtBat        CHits       CHmRun \n  79.4509472    1.2833513    3.2274264   -0.3752350    1.4957073    1.4420538 \n   DivisionW      PutOuts \n-129.9866432    0.2366813 \n```\n\n\n:::\n:::\n\n\nIn fact, we see that the best seven-variable model on the full data set has a different set of variables than the best seven-variable model on the training set.\n\nWe now try to choose among the models of different sizes using cross-validation. This approach is somewhat involved, as we must perform best subset selection *within each of the* $k$ training sets. Despite this, we see that with its clever subsetting syntax, `R` makes this job quite easy. First, we create a vector that allocates each observation to one of $k=10$ folds, and we create a matrix in which we will store the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 10\nn <- nrow(Hitters)\nset.seed(1)\nfolds <- sample(rep(1:k, length = n))\ncv.errors <- matrix(NA, k, 19,\n    dimnames = list(NULL, paste(1:19)))\n```\n:::\n\n\nNow we write a for loop that performs cross-validation. In the $j$th fold, the elements of `folds` that equal `j` are in the test set, and the remainder are in the training set. We make our predictions for each model size (using our new `predict()` method), compute the test errors on the appropriate subset, and store them in the appropriate slot in the matrix `cv.errors`. Note that in the following code `R` will automatically use our `predict.regsubsets()` function when we call `predict()` because the `best.fit` object has class `regsubsets`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (j in 1:k) {\n  best.fit <- regsubsets(Salary ~ .,\n       data = Hitters[folds != j, ],\n       nvmax = 19)\n  for (i in 1:19) {\n    pred <- predict(best.fit, Hitters[folds == j, ], id = i)\n    cv.errors[j, i] <-\n         mean((Hitters$Salary[folds == j] - pred)^2)\n   }\n }\n```\n:::\n\n\nThis has given us a $10 \\times 19$ matrix, of which the $(j,i)$th element corresponds to the test MSE for the $j$th cross-validation fold for the best $i$-variable model. We use the `apply()` function to average over the columns of this matrix in order to obtain a vector for which the $i$th element is the cross-validation error for the $i$-variable model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean.cv.errors <- apply(cv.errors, 2, mean)\nmean.cv.errors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       1        2        3        4        5        6        7        8 \n143439.8 126817.0 134214.2 131782.9 130765.6 120382.9 121443.1 114363.7 \n       9       10       11       12       13       14       15       16 \n115163.1 109366.0 112738.5 113616.5 115557.6 115853.3 115630.6 116050.0 \n      17       18       19 \n116117.0 116419.3 116299.1 \n```\n\n\n:::\n\n```{.r .cell-code}\npar(mfrow = c(1, 1))\nplot(mean.cv.errors, type = \"b\")\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/cv-results-1.png){width=672}\n:::\n:::\n\n\nWe see that cross-validation selects a 10-variable model. We now perform best subset selection on the full data set in order to obtain the 10-variable model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg.best <- regsubsets(Salary ~ ., data = Hitters,\n    nvmax = 19)\ncoef(reg.best, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)        AtBat         Hits        Walks       CAtBat        CRuns \n 162.5354420   -2.1686501    6.9180175    5.7732246   -0.1300798    1.4082490 \n        CRBI       CWalks    DivisionW      PutOuts      Assists \n   0.7743122   -0.8308264 -112.3800575    0.2973726    0.2831680 \n```\n\n\n:::\n:::\n\n\n## Ridge Regression and the Lasso\n\nWe will use the `glmnet` package in order to perform ridge regression and the lasso. The main function in this package is `glmnet()`, which can be used to fit ridge regression models, lasso models, and more. This function has slightly different syntax from other model-fitting functions that we have encountered thus far in this book. In particular, we must pass in an `x` matrix as well as a `y` vector, and we do not use the `y ~ x` syntax. We will now perform ridge regression and the lasso in order to predict `Salary` on the `Hitters` data. Before proceeding ensure that the missing values have been removed from the data, as described in Section 6.5.1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- model.matrix(Salary ~ ., Hitters)[, -1]\ny <- Hitters$Salary\n```\n:::\n\n\nThe `model.matrix()` function is particularly useful for creating `x`; not only does it produce a matrix corresponding to the $19$ predictors but it also automatically transforms any qualitative variables into dummy variables. The latter property is important because `glmnet()` can only take numerical, quantitative inputs.\n\n### Ridge Regression\n\nThe `glmnet()` function has an `alpha` argument that determines what type of model is fit. If `alpha=0` then a ridge regression model is fit, and if `alpha=1` then a lasso model is fit. We first fit a ridge regression model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- 10^seq(10, -2, length = 100)\nridge.mod <- glmnet(x, y, alpha = 0, lambda = grid)\n```\n:::\n\n\nBy default the `glmnet()` function performs ridge regression for an automatically selected range of $\\lambda$ values. However, here we have chosen to implement the function over a grid of values ranging from $\\lambda=10^{10}$ to $\\lambda=10^{-2}$, essentially covering the full range of scenarios from the null model containing only the intercept, to the least squares fit. As we will see, we can also compute model fits for a particular value of $\\lambda$ that is not one of the original `grid` values. Note that by default, the `glmnet()` function standardizes the variables so that they are on the same scale. To turn off this default setting, use the argument `standardize = FALSE`.\n\nAssociated with each value of $\\lambda$ is a vector of ridge regression coefficients, stored in a matrix that can be accessed by `coef()`. In this case, it is a $20 \\times 100$ matrix, with $20$ rows (one for each predictor, plus an intercept) and $100$ columns (one for each value of $\\lambda$).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(coef(ridge.mod))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  20 100\n```\n\n\n:::\n:::\n\n\nWe expect the coefficient estimates to be much smaller, in terms of $\\ell_2$ norm, when a large value of $\\lambda$ is used, as compared to when a small value of $\\lambda$ is used. These are the coefficients when $\\lambda=11{,}498$, along with their $\\ell_2$ norm:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nridge.mod$lambda[50]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11497.57\n```\n\n\n:::\n\n```{.r .cell-code}\ncoef(ridge.mod)[, 50]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept)         AtBat          Hits         HmRun          Runs \n407.356050200   0.036957182   0.138180344   0.524629976   0.230701523 \n          RBI         Walks         Years        CAtBat         CHits \n  0.239841459   0.289618741   1.107702929   0.003131815   0.011653637 \n       CHmRun         CRuns          CRBI        CWalks       LeagueN \n  0.087545670   0.023379882   0.024138320   0.025015421   0.085028114 \n    DivisionW       PutOuts       Assists        Errors    NewLeagueN \n -6.215440973   0.016482577   0.002612988  -0.020502690   0.301433531 \n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(sum(coef(ridge.mod)[-1, 50]^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.360612\n```\n\n\n:::\n:::\n\n\nIn contrast, here are the coefficients when $\\lambda=705$, along with their $\\ell_2$ norm. Note the much larger $\\ell_2$ norm of the coefficients associated with this smaller value of $\\lambda$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nridge.mod$lambda[60]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 705.4802\n```\n\n\n:::\n\n```{.r .cell-code}\ncoef(ridge.mod)[, 60]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)        AtBat         Hits        HmRun         Runs          RBI \n 54.32519950   0.11211115   0.65622409   1.17980910   0.93769713   0.84718546 \n       Walks        Years       CAtBat        CHits       CHmRun        CRuns \n  1.31987948   2.59640425   0.01083413   0.04674557   0.33777318   0.09355528 \n        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists \n  0.09780402   0.07189612  13.68370191 -54.65877750   0.11852289   0.01606037 \n      Errors   NewLeagueN \n -0.70358655   8.61181213 \n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(sum(coef(ridge.mod)[-1, 60]^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 57.11001\n```\n\n\n:::\n:::\n\n\nWe can use the `predict()` function for a number of purposes. For instance, we can obtain the ridge regression coefficients for a new value of $\\lambda$, say $50$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredict(ridge.mod, s = 50, type = \"coefficients\")[1:20, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept)         AtBat          Hits         HmRun          Runs \n 4.876610e+01 -3.580999e-01  1.969359e+00 -1.278248e+00  1.145892e+00 \n          RBI         Walks         Years        CAtBat         CHits \n 8.038292e-01  2.716186e+00 -6.218319e+00  5.447837e-03  1.064895e-01 \n       CHmRun         CRuns          CRBI        CWalks       LeagueN \n 6.244860e-01  2.214985e-01  2.186914e-01 -1.500245e-01  4.592589e+01 \n    DivisionW       PutOuts       Assists        Errors    NewLeagueN \n-1.182011e+02  2.502322e-01  1.215665e-01 -3.278600e+00 -9.496680e+00 \n```\n\n\n:::\n:::\n\n\nWe now split the samples into a training set and a test set in order to estimate the test error of ridge regression and the lasso. There are two common ways to randomly split a data set. The first is to produce a random vector of `TRUE`, `FALSE` elements and select the observations corresponding to `TRUE` for the training data. The second is to randomly choose a subset of numbers between $1$ and $n$; these can then be used as the indices for the training observations. The two approaches work equally well. We used the former method in Section 6.5.1. Here we demonstrate the latter approach.\n\nWe first set a random seed so that the results obtained will be reproducible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\ntrain <- sample(1:nrow(x), nrow(x) / 2)\ntest <- (-train)\ny.test <- y[test]\n```\n:::\n\n\nNext we fit a ridge regression model on the training set, and evaluate its MSE on the test set, using $\\lambda=4$. Note the use of the `predict()` function again. This time we get predictions for a test set, by replacing `type=\"coefficients\"` with the `newx` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nridge.mod <- glmnet(x[train, ], y[train], alpha = 0,\n    lambda = grid, thresh = 1e-12)\n\nridge.pred <- predict(ridge.mod, s = 4, newx = x[test, ])\nmean((ridge.pred - y.test)^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 142199.2\n```\n\n\n:::\n:::\n\n\nThe test MSE is $142{,}199$. Note that if we had instead simply fit a model with just an intercept, we would have predicted each test observation using the mean of the training observations. In that case, we could compute the test set MSE like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean((mean(y[train]) - y.test)^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 224669.9\n```\n\n\n:::\n:::\n\n\nWe could also get the same result by fitting a ridge regression model with a *very* large value of $\\lambda$. Note that `1e10` means $10^{10}$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nridge.pred <- predict(ridge.mod, s = 1e10, newx = x[test, ])\nmean((ridge.pred - y.test)^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 224669.8\n```\n\n\n:::\n:::\n\n\nSo fitting a ridge regression model with $\\lambda=4$ leads to a much lower test MSE than fitting a model with just an intercept. We now check whether there is any benefit to performing ridge regression with $\\lambda=4$ instead of just performing least squares regression. Recall that least squares is simply ridge regression with $\\lambda=0$. (In order for `glmnet()` to yield the exact least squares coefficients when $\\lambda=0$, we use the argument `exact = T` when calling the `predict()` function. Otherwise, the `predict()` function will interpolate over the grid of $\\lambda$ values used in fitting the `glmnet()` model, yielding approximate results. When we use `exact = T`, there remains a slight discrepancy in the third decimal place between the output of `glmnet()` when $\\lambda = 0$ and the output of `lm()`; this is due to numerical approximation on the part of `glmnet()`.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nridge.pred <- predict(ridge.mod, s = 0, newx = x[test, ],\n    exact = T, x = x[train, ], y = y[train])\nmean((ridge.pred - y.test)^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 168588.6\n```\n\n\n:::\n\n```{.r .cell-code}\nlm(y ~ x, subset = train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x, subset = train)\n\nCoefficients:\n(Intercept)       xAtBat        xHits       xHmRun        xRuns         xRBI  \n   274.0145      -0.3521      -1.6377       5.8145       1.5424       1.1243  \n     xWalks       xYears      xCAtBat       xCHits      xCHmRun       xCRuns  \n     3.7287     -16.3773      -0.6412       3.1632       3.4008      -0.9739  \n      xCRBI      xCWalks     xLeagueN   xDivisionW     xPutOuts     xAssists  \n    -0.6005       0.3379     119.1486    -144.0831       0.1976       0.6804  \n    xErrors  xNewLeagueN  \n    -4.7128     -71.0951  \n```\n\n\n:::\n\n```{.r .cell-code}\npredict(ridge.mod, s = 0, exact = T, type = \"coefficients\",\n    x = x[train, ], y = y[train])[1:20, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)        AtBat         Hits        HmRun         Runs          RBI \n 274.0200994   -0.3521900   -1.6371383    5.8146692    1.5423361    1.1241837 \n       Walks        Years       CAtBat        CHits       CHmRun        CRuns \n   3.7288406  -16.3795195   -0.6411235    3.1629444    3.4005281   -0.9739405 \n        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists \n  -0.6003976    0.3378422  119.1434637 -144.0853061    0.1976300    0.6804200 \n      Errors   NewLeagueN \n  -4.7127879  -71.0898914 \n```\n\n\n:::\n:::\n\n\nIn general, if we want to fit a (unpenalized) least squares model, then we should use the `lm()` function, since that function provides more useful outputs, such as standard errors and p-values for the coefficients.\n\nIn general, instead of arbitrarily choosing $\\lambda=4$, it would be better to use cross-validation to choose the tuning parameter $\\lambda$. We can do this using the built-in cross-validation function, `cv.glmnet()`. By default, the function performs ten-fold cross-validation, though this can be changed using the argument `nfolds`. Note that we set a random seed first so our results will be reproducible, since the choice of the cross-validation folds is random.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\ncv.out <- cv.glmnet(x[train, ], y[train], alpha = 0)\nplot(cv.out)\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/cv-ridge-1.png){width=672}\n:::\n\n```{.r .cell-code}\nbestlam <- cv.out$lambda.min\nbestlam\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 326.0828\n```\n\n\n:::\n:::\n\n\nTherefore, we see that the value of $\\lambda$ that results in the smallest cross-validation error is $326$. What is the test MSE associated with this value of $\\lambda$?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nridge.pred <- predict(ridge.mod, s = bestlam,\n    newx = x[test, ])\nmean((ridge.pred - y.test)^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 139856.6\n```\n\n\n:::\n:::\n\n\nThis represents a further improvement over the test MSE that we got using $\\lambda=4$. Finally, we refit our ridge regression model on the full data set, using the value of $\\lambda$ chosen by cross-validation, and examine the coefficient estimates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- glmnet(x, y, alpha = 0)\npredict(out, type = \"coefficients\", s = bestlam)[1:20, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n (Intercept)        AtBat         Hits        HmRun         Runs          RBI \n 15.44383120   0.07715547   0.85911582   0.60103106   1.06369007   0.87936105 \n       Walks        Years       CAtBat        CHits       CHmRun        CRuns \n  1.62444617   1.35254778   0.01134999   0.05746654   0.40680157   0.11456224 \n        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists \n  0.12116504   0.05299202  22.09143197 -79.04032656   0.16619903   0.02941950 \n      Errors   NewLeagueN \n -1.36092945   9.12487765 \n```\n\n\n:::\n:::\n\n\nAs expected, none of the coefficients are zero---ridge regression does not perform variable selection!\n\n### The Lasso\n\nWe saw that ridge regression with a wise choice of $\\lambda$ can outperform least squares as well as the null model on the `Hitters` data set. We now ask whether the lasso can yield either a more accurate or a more interpretable model than ridge regression. In order to fit a lasso model, we once again use the `glmnet()` function; however, this time we use the argument `alpha=1`. Other than that change, we proceed just as we did in fitting a ridge model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlasso.mod <- glmnet(x[train, ], y[train], alpha = 1,\n    lambda = grid)\nplot(lasso.mod)\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/lasso-hitters-1.png){width=672}\n:::\n:::\n\n\nWe can see from the coefficient plot that depending on the choice of tuning parameter, some of the coefficients will be exactly equal to zero. We now perform cross-validation and compute the associated test error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\ncv.out <- cv.glmnet(x[train, ], y[train], alpha = 1)\nplot(cv.out)\n```\n\n::: {.cell-output-display}\n![](07-model-selection-regularization_files/figure-html/cv-lasso-1.png){width=672}\n:::\n\n```{.r .cell-code}\nbestlam <- cv.out$lambda.min\nlasso.pred <- predict(lasso.mod, s = bestlam,\n    newx = x[test, ])\nmean((lasso.pred - y.test)^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 143673.6\n```\n\n\n:::\n:::\n\n\nThis is substantially lower than the test set MSE of the null model and of least squares, and very similar to the test MSE of ridge regression with $\\lambda$ chosen by cross-validation.\n\nHowever, the lasso has a substantial advantage over ridge regression in that the resulting coefficient estimates are sparse. Here we see that 8 of the 19 coefficient estimates are exactly zero. So the lasso model with $\\lambda$ chosen by cross-validation contains only eleven variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- glmnet(x, y, alpha = 1, lambda = grid)\nlasso.coef <- predict(out, type = \"coefficients\",\n    s = bestlam)[1:20, ]\nlasso.coef\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept)         AtBat          Hits         HmRun          Runs \n   1.27479059   -0.05497143    2.18034583    0.00000000    0.00000000 \n          RBI         Walks         Years        CAtBat         CHits \n   0.00000000    2.29192406   -0.33806109    0.00000000    0.00000000 \n       CHmRun         CRuns          CRBI        CWalks       LeagueN \n   0.02825013    0.21628385    0.41712537    0.00000000   20.28615023 \n    DivisionW       PutOuts       Assists        Errors    NewLeagueN \n-116.16755870    0.23752385    0.00000000   -0.85629148    0.00000000 \n```\n\n\n:::\n\n```{.r .cell-code}\nlasso.coef[lasso.coef != 0]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept)         AtBat          Hits         Walks         Years \n   1.27479059   -0.05497143    2.18034583    2.29192406   -0.33806109 \n       CHmRun         CRuns          CRBI       LeagueN     DivisionW \n   0.02825013    0.21628385    0.41712537   20.28615023 -116.16755870 \n      PutOuts        Errors \n   0.23752385   -0.85629148 \n```\n\n\n:::\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}