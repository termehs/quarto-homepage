{
  "hash": "6fe7f5ae8444fc8c69b115da330ce931",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor:  Termeh Shafie\ntitle: \"Social Network Analysis\"\nsubtitle: \"Worksheet 7: Network Visualization II\"\nlightbox: auto\ntoc: true\nformat:\n  html:\n    embed-resources: true\n    fig-width: 10\n    fig-height: 10\n---\n\n## Load Packages\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(graphlayouts)\nlibrary(ggraph)\nlibrary(networkdata)\n```\n:::\n\n\n\n## Dynamic layouts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gganimate)\nlibrary(ggplot2)\nlibrary(patchwork)\n# also install package 'gifski' to create gifs\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# downloaded from https://www.stats.ox.ac.uk/~snijders/siena/siena_datasets.htm\ndata(\"s50\")\ns50\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nIGRAPH dd2aeb6 UN-- 50 74 -- \n+ attr: name (v/c), smoke (v/n)\n+ edges from dd2aeb6 (vertex names):\n [1] V1 --V11 V1 --V14 V2 --V7  V2 --V11 V3 --V4  V3 --V9  V4 --V9  V5 --V32\n [9] V6 --V8  V7 --V12 V7 --V26 V7 --V42 V7 --V44 V10--V11 V10--V14 V10--V15\n[17] V10--V33 V11--V14 V11--V15 V11--V16 V11--V19 V11--V30 V12--V42 V12--V44\n[25] V15--V16 V17--V18 V17--V19 V17--V21 V17--V22 V17--V24 V18--V19 V18--V35\n[33] V19--V24 V19--V26 V19--V30 V21--V22 V21--V24 V21--V31 V21--V32 V22--V24\n[41] V22--V25 V22--V31 V22--V34 V22--V43 V23--V24 V25--V31 V25--V32 V26--V29\n[49] V26--V30 V26--V44 V27--V28 V27--V29 V27--V30 V29--V30 V29--V33 V30--V33\n[57] V31--V32 V31--V34 V31--V37 V32--V37 V34--V37 V36--V38 V36--V41 V38--V41\n+ ... omitted several edges\n\n[[2]]\nIGRAPH 6e28c77 UN-- 50 81 -- \n+ attr: name (v/c), smoke (v/n)\n+ edges from 6e28c77 (vertex names):\n [1] V1 --V10 V1 --V11 V1 --V14 V1 --V33 V2 --V26 V3 --V4  V3 --V9  V4 --V5 \n [9] V4 --V17 V4 --V34 V5 --V17 V6 --V8  V6 --V35 V7 --V26 V7 --V44 V10--V11\n[17] V10--V14 V10--V33 V11--V14 V11--V19 V11--V26 V11--V30 V12--V15 V12--V26\n[25] V12--V42 V12--V44 V15--V16 V15--V36 V15--V42 V16--V26 V16--V42 V16--V44\n[33] V17--V22 V17--V24 V17--V27 V17--V32 V18--V35 V19--V21 V19--V23 V19--V30\n[41] V19--V36 V19--V41 V21--V31 V21--V37 V21--V40 V22--V24 V23--V50 V24--V25\n[49] V24--V28 V25--V27 V25--V28 V25--V32 V26--V42 V27--V28 V28--V35 V29--V30\n[57] V29--V33 V29--V42 V30--V33 V30--V36 V30--V41 V31--V32 V31--V37 V32--V37\n+ ... omitted several edges\n\n[[3]]\nIGRAPH 9285b7f UN-- 50 77 -- \n+ attr: name (v/c), smoke (v/n)\n+ edges from 9285b7f (vertex names):\n [1] V1 --V10 V1 --V11 V1 --V14 V1 --V41 V2 --V7  V2 --V23 V2 --V26 V3 --V4 \n [9] V3 --V9  V3 --V34 V4 --V32 V4 --V34 V5 --V17 V5 --V32 V6 --V24 V6 --V27\n[17] V6 --V28 V7 --V16 V7 --V26 V7 --V42 V7 --V44 V8 --V25 V10--V11 V10--V12\n[25] V10--V14 V10--V33 V11--V14 V11--V15 V11--V33 V12--V15 V12--V33 V14--V33\n[33] V15--V29 V15--V33 V15--V36 V16--V26 V16--V42 V16--V44 V17--V22 V17--V27\n[41] V19--V29 V19--V30 V19--V36 V21--V31 V21--V37 V21--V40 V21--V45 V24--V27\n[49] V24--V28 V25--V50 V26--V44 V27--V28 V29--V30 V29--V33 V30--V33 V30--V36\n[57] V31--V37 V35--V37 V35--V50 V36--V38 V36--V41 V37--V47 V38--V41 V39--V43\n+ ... omitted several edges\n```\n\n\n:::\n:::\n\n\nThe dataset consists of three networks with 50 actors each and a vertex attribute for the smoking behaviour of students. As a first step, we need to create a layout for all three networks. You can basically use any type of layout for each network, but I’d recommend layout_as_dynamic() from the package {{graphlayouts}}. The algorithm calculates a reference layout which is a layout of the union of all networks and individual layouts based on stress minimization and combines those in a linear combination which is controlled by the alpha parameter. For alpha=1, only the reference layout is used and all graphs have the same layout. For alpha=0, the stress layout of each individual graph is used. Values in-between interpolate between the two layouts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Try other values for alpha\nxy <- layout_as_dynamic(s50, alpha = 0.2)\npList <- vector(\"list\", length(s50))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#static plots\nfor (i in 1:length(s50)) {\n  pList[[i]] <- ggraph(s50[[i]], layout = \"manual\", x = xy[[i]][, 1], y = xy[[i]][, 2]) +\n    geom_edge_link0(edge_width = 0.6, edge_colour = \"grey66\") +\n    geom_node_point(shape = 21, aes(fill = as.factor(smoke)), size = 6) +\n    geom_node_text(label = 1:50, repel = FALSE, color = \"white\", size = 4) +\n    scale_fill_manual(\n      values = c(\"forestgreen\", \"grey25\", \"firebrick\"),\n      guide = ifelse(i != 2, \"none\", \"legend\"),\n      name = \"smoking\",\n      labels = c(\"never\", \"occasionally\", \"regularly\")\n    ) +\n    theme_graph() +\n    theme(legend.position = \"bottom\") +\n    labs(title = paste0(\"Wave \", i))\n}\n# Reduce(\"+\", pList)\npList[[1]] + pList[[2]] + pList[[3]]\n```\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/s50_static-1.png){width=1152}\n:::\n:::\n\n\nThis is nice but of course we want to animate the changes. This is where we say goodbye to ggraph and hello to good-old ggplot2. First, we create a list of data frames for all nodes and add the layout to it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a list which contains all nodes and layout\nnodes_lst <- lapply(1:length(s50), function(i) {\n  cbind(igraph::as_data_frame(s50[[i]], \"vertices\"),\n    x = xy[[i]][, 1], y = xy[[i]][, 2], frame = i\n  )\n})\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_lst <- lapply(1:length(s50), function(i) {\n  cbind(igraph::as_data_frame(s50[[i]], \"edges\"), frame = i)\n})\n\nedges_lst <- lapply(1:length(s50), function(i) {\n  edges_lst[[i]]$x <- nodes_lst[[i]]$x[match(edges_lst[[i]]$from, nodes_lst[[i]]$name)]\n  edges_lst[[i]]$y <- nodes_lst[[i]]$y[match(edges_lst[[i]]$from, nodes_lst[[i]]$name)]\n  edges_lst[[i]]$xend <- nodes_lst[[i]]$x[match(edges_lst[[i]]$to, nodes_lst[[i]]$name)]\n  edges_lst[[i]]$yend <- nodes_lst[[i]]$y[match(edges_lst[[i]]$to, nodes_lst[[i]]$name)]\n  edges_lst[[i]]$id <- paste0(edges_lst[[i]]$from, \"-\", edges_lst[[i]]$to)\n  edges_lst[[i]]$status <- TRUE\n  edges_lst[[i]]\n})\n\nhead(edges_lst[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  from  to frame         x         y      xend       yend     id status\n1   V1 V11     1  1.803046  0.247353  2.123787 -0.7457415 V1-V11   TRUE\n2   V1 V14     1  1.803046  0.247353  2.391336  0.2295657 V1-V14   TRUE\n3   V2  V7     1  3.623264 -1.313577  3.870197 -1.9488863  V2-V7   TRUE\n4   V2 V11     1  3.623264 -1.313577  2.123787 -0.7457415 V2-V11   TRUE\n5   V3  V4     1 -4.877254 -2.719843 -3.854924 -2.8766208  V3-V4   TRUE\n6   V3  V9     1 -4.877254 -2.719843 -5.416373 -3.4092101  V3-V9   TRUE\n```\n\n\n:::\n:::\n\n\nWe have expanded the edge data frame in a way that also includes the coordinates of the endpoints from the layout that we calculated earlier.\n\nNow we create a helper matrix which includes all edges that are present in any of the networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_edges <- do.call(\"rbind\", lapply(s50, get.edgelist))\nall_edges <- all_edges[!duplicated(all_edges), ]\nall_edges <- cbind(all_edges, paste0(all_edges[, 1], \"-\", all_edges[, 2]))\n```\n:::\n\n\nThis is used to impute the edges into all networks. So any edge that is not present in time frame two and three gets added to time frame one. But to keep track of these, we set there status to FALSE.\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_lst <- lapply(1:length(s50), function(i) {\n  idx <- which(!all_edges[, 3] %in% edges_lst[[i]]$id)\n  if (length(idx != 0)) {\n    tmp <- data.frame(from = all_edges[idx, 1], to = all_edges[idx, 2], id = all_edges[idx, 3])\n    tmp$x <- nodes_lst[[i]]$x[match(tmp$from, nodes_lst[[i]]$name)]\n    tmp$y <- nodes_lst[[i]]$y[match(tmp$from, nodes_lst[[i]]$name)]\n    tmp$xend <- nodes_lst[[i]]$x[match(tmp$to, nodes_lst[[i]]$name)]\n    tmp$yend <- nodes_lst[[i]]$y[match(tmp$to, nodes_lst[[i]]$name)]\n    tmp$frame <- i\n    tmp$status <- FALSE\n    edges_lst[[i]] <- rbind(edges_lst[[i]], tmp)\n  }\n  edges_lst[[i]]\n})\n```\n:::\n\n\nWhy are we doing this? After a lot of experimenting, I came to the conclusion that it is always best to draw all edges, but use zero opacity if status = FALSE. In that way, one gets a smoother transition for edges that (dis)appear. There are probably other workarounds though.\n\nIn the last step, we create a data frame out of the lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_df <- do.call(\"rbind\", edges_lst)\nnodes_df <- do.call(\"rbind\", nodes_lst)\n\nhead(edges_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  from  to frame         x         y      xend       yend     id status\n1   V1 V11     1  1.803046  0.247353  2.123787 -0.7457415 V1-V11   TRUE\n2   V1 V14     1  1.803046  0.247353  2.391336  0.2295657 V1-V14   TRUE\n3   V2  V7     1  3.623264 -1.313577  3.870197 -1.9488863  V2-V7   TRUE\n4   V2 V11     1  3.623264 -1.313577  2.123787 -0.7457415 V2-V11   TRUE\n5   V3  V4     1 -4.877254 -2.719843 -3.854924 -2.8766208  V3-V4   TRUE\n6   V3  V9     1 -4.877254 -2.719843 -5.416373 -3.4092101  V3-V9   TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(nodes_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   name smoke         x         y frame\nV1   V1     2  1.803046  0.247353     1\nV2   V2     3  3.623264 -1.313577     1\nV3   V3     1 -4.877254 -2.719843     1\nV4   V4     1 -3.854924 -2.876621     1\nV5   V5     1 -2.824439 -3.368968     1\nV6   V6     1 -1.529341 -5.292054     1\n```\n\n\n:::\n:::\n\n\nAnd that’s it in terms of data wrangling. All that is left is to plot/animate the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_segment(\n    data = edges_df,\n    aes(x = x, xend = xend, y = y, yend = yend, group = id, alpha = status),\n    show.legend = FALSE\n  ) +\n  geom_point(\n    data = nodes_df, aes(x, y, group = name, fill = as.factor(smoke)),\n    shape = 21, size = 4, show.legend = FALSE\n  ) +\n  scale_fill_manual(values = c(\"forestgreen\", \"grey25\", \"firebrick\")) +\n  scale_alpha_manual(values = c(0, 1)) +\n  ease_aes(\"quadratic-in-out\") +\n  transition_states(frame, state_length = 0.5, wrap = FALSE) +\n  labs(title = \"Wave {closest_state}\") +\n  theme_void()\n```\n:::\n\n\n![](s50.gif)\n\n\n## Interactive plots with visNetwork\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(visNetwork)\ndata(\"karate\")\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvisIgraph(karate)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"visNetwork html-widget html-fill-item\" id=\"htmlwidget-f8aab761826318712f90\" style=\"width:100%;height:650px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-f8aab761826318712f90\">{\"x\":{\"nodes\":{\"id\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34],\"label\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34],\"x\":[0.2515291479646338,-0.2316850740499974,-0.1505300757744298,0.05184792286646434,0.6399750586087429,0.8204649933826567,0.6413085864867223,-0.1294473702593243,-0.2220422338211731,-0.7423048760975526,0.8451307496081579,0.9179035484761096,0.2379013535215351,-0.0187202283525344,-0.8161669865164185,-0.6168925817565076,1,-0.2696733097246384,-0.9664716669814233,-0.3006285932127424,-1,-0.06325450806440358,-0.8771184920486885,-0.0824431306791511,0.5560129746424081,0.3925778257432468,-0.4560077496049114,0.09682689472448613,-0.07081600319820713,-0.3530684960619928,-0.5199070599743072,0.1667025976257919,-0.5025122309546555,-0.4182496537713177],\"y\":[-0.2790226179505227,-0.2269675913295932,0.08217514214673916,-0.2611113035560412,-0.5697396130723664,-0.6877520782129571,-0.7622272406976084,-0.3203846767711147,0.185751028925357,0.1921920468472731,-0.4848463737571449,-0.243119570518523,-0.57362923091062,-0.0007893941525430881,0.8102483138270198,0.8073560864820477,-1,-0.5436665167941784,0.4522999632717302,-0.02967773955646313,0.5917538115089038,-0.580807428162837,0.6875820998558519,0.7463498297336972,0.6318048738503437,0.7712482352072447,1,0.5324941547696318,0.3779990886746023,0.8323264587336952,0.1710573681343219,0.3709580803244921,0.521740748088342,0.481756264097317]},\"edges\":{\"from\":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,5,5,6,6,6,7,9,9,9,10,14,15,15,16,16,19,19,20,21,21,23,23,24,24,24,24,24,25,25,25,26,27,27,28,29,29,30,30,31,31,32,32,33],\"to\":[2,3,4,5,6,7,8,9,11,12,13,14,18,20,22,32,3,4,8,14,18,20,22,31,4,8,9,10,14,28,29,33,8,13,14,7,11,7,11,17,17,31,33,34,34,34,33,34,33,34,33,34,34,33,34,33,34,26,28,30,33,34,26,28,32,32,30,34,34,32,34,33,34,33,34,33,34,34]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"physics\":false},\"manipulation\":{\"enabled\":false},\"edges\":{\"smooth\":false},\"physics\":{\"stabilization\":false}},\"groups\":null,\"width\":null,\"height\":null,\"idselection\":{\"enabled\":false},\"byselection\":{\"enabled\":false},\"main\":null,\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"igraphlayout\":{\"type\":\"square\"}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkarate_df <- toVisNetworkData(karate)\nvisNetwork(nodes = karate_df$nodes, \n           edges = karate_df$edges, height = \"300px\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"htmlwidget-007fd34f5d4d1d17d97d\" style=\"width:960px;height:300px;\" class=\"visNetwork html-widget\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-007fd34f5d4d1d17d97d\">{\"x\":{\"nodes\":{\"id\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34],\"label\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]},\"edges\":{\"from\":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,5,5,6,6,6,7,9,9,9,10,14,15,15,16,16,19,19,20,21,21,23,23,24,24,24,24,24,25,25,25,26,27,27,28,29,29,30,30,31,31,32,32,33],\"to\":[2,3,4,5,6,7,8,9,11,12,13,14,18,20,22,32,3,4,8,14,18,20,22,31,4,8,9,10,14,28,29,33,8,13,14,7,11,7,11,17,17,31,33,34,34,34,33,34,33,34,33,34,34,33,34,33,34,26,28,30,33,34,26,28,32,32,30,34,34,32,34,33,34,33,34,33,34,34]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\"},\"manipulation\":{\"enabled\":false}},\"groups\":null,\"width\":null,\"height\":\"300px\",\"idselection\":{\"enabled\":false},\"byselection\":{\"enabled\":false},\"main\":null,\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n## Gimmicks\nThe `ggforce` package works pretty nicely with `ggraph`. You can, for instance, use\nthe `geom_mark_*()` functions to highlight clusters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggforce)\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(665)\n\n#create network with a group structure\ng <- sample_islands(9, 40, 0.4, 15)\ng <- simplify(g)\nV(g)$grp <- as.character(rep(1:9, each = 40))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g, layout = \"backbone\", keep = 0.4) +\n  geom_edge_link0(edge_color = \"grey66\", edge_width = 0.2) +\n  geom_node_point(aes(fill = grp), shape = 21, size = 3) +\n  geom_mark_hull(\n    aes(x, y, group = grp, fill = grp),\n    concavity = 4,\n    expand = unit(2, \"mm\"),\n    alpha = 0.25\n  ) +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_fill_brewer(palette = \"Set1\") +\n  theme_graph()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/network_grps_sol-1.png){width=960}\n:::\n:::\n\n\nOf course you can also add a label to your clusters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g, layout = \"backbone\", keep = 0.4) +\n  geom_edge_link0(edge_color = \"grey66\", edge_width = 0.2) +\n  geom_node_point(aes(fill = grp), shape = 21, size = 3) +\n  geom_mark_hull(\n    aes(x, y, group = grp, fill = grp, label=grp),\n    concavity = 4,\n    expand = unit(2, \"mm\"),\n    alpha = 0.25\n  ) +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_fill_brewer(palette = \"Set1\") +\n  theme_graph()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/network_grps_label_sol-1.png){width=960}\n:::\n:::\n\n\n> \"How can I achieve that my directed edges stop at the node border, independent from the node size?\" \n\nOut of the box you will probably end up with something like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a random network\nset.seed(1071)\ng <- sample_pa(30, 1)\nV(g)$degree <- degree(g, mode = \"in\")\n\nggraph(g, \"stress\") +\n  geom_edge_link(\n    aes(end_cap = circle(node2.degree + 2, \"pt\")),\n    edge_colour = \"black\",\n    arrow = arrow(\n      angle = 10,\n      length = unit(0.15, \"inches\"),\n      ends = \"last\",\n      type = \"closed\"\n    )\n  ) +\n  geom_node_point(aes(size = degree), col = \"grey66\", show.legend = FALSE) +\n  scale_size(range = c(3, 11)) +\n  theme_graph()\n```\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/arrow_size-1.png){width=960}\n:::\n:::\n\n\nThe overlap can be avoided by using the `I()` function from base R, which\ntreats the entries of a vector \"as is\". So we know that if a node has degree 5, it will be mapped to\na circle with radius (or diameter?) \"5pt\". Since this means, that you have no control over the scaling, you need to do that beforehand.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormalise <- function(x, from = range(x), to = c(0, 1)) {\n  x <- (x - from[1]) / (from[2] - from[1])\n  if (!identical(to, c(0, 1))) {\n    x <- x * (to[2] - to[1]) + to[1]\n  }\n  x\n}\n\n# map to the range you want\nV(g)$degree <- normalise(V(g)$degree, to = c(3, 11))\n\nggraph(g, \"stress\") +\n  geom_edge_link(\n    aes(end_cap = circle(node2.degree + 2, \"pt\")),\n    edge_colour = \"grey25\",\n    arrow = arrow(\n      angle = 10,\n      length = unit(0.15, \"inches\"),\n      ends = \"last\",\n      type = \"closed\"\n    )\n  ) +\n  geom_node_point(aes(size = I(degree)), col = \"grey66\") +\n  theme_graph()\n```\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/arrows_size_sol-1.png){width=960}\n:::\n:::\n\n\n> \"How can I lower the opacity of nodes without making edges visible underneath?\"\n\nOne of the rules you should try to follow is that edges should not be visible on top of nodes. Usually that is easy to achieve by drawing the edges before the nodes. But if you  want to lower the opacity of nodes, they do become visible again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- sample_gnp(20, 0.5)\nV(g)$degree <- degree(g)\n\nggraph(g, \"stress\") +\n  geom_edge_link(edge_colour = \"grey66\") +\n  geom_node_point(\n    size = 8,\n    aes(alpha = degree),\n    col = \"red\",\n    show.legend = FALSE\n  ) +\n  theme_graph()\n```\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/alpha_nodes-1.png){width=960}\n:::\n:::\n\n\nThe solution is rather simple. Just add a node layer with the same aesthetics below with\n`alpha=1` (default) and `color=\"white\"` (or the background color of the plot).\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g, \"stress\") +\n  geom_edge_link(edge_colour = \"grey66\") +\n  geom_node_point(size = 8, col = \"white\") +\n  geom_node_point(\n    aes(alpha = degree),\n    size = 8,\n    col = \"red\",\n    show.legend = FALSE\n  ) +\n  theme_graph()\n```\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/alpha_nodes_sol-1.png){width=960}\n:::\n:::\n\n\nOf course you could also use `start_cap` and `end_cap` here, but you may have to fiddle again as in the last example. \n\n> \"How can I enhance readability of node labels in hairball graphs?\"\n\nSometimes it is really hard to make labels readable when the network is very cluttered\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- sample_gnp(50, 0.7)\nV(g)$name <- sapply(1:50, function(x) paste0(sample(LETTERS, 4), collapse = \"\"))\nE(g)$weight <- runif(ecount(g))\n\nggraph(g) +\n  geom_edge_link0(aes(edge_color = weight, edge_width = weight), show.legend = FALSE) +\n  geom_node_point(size = 8, color = \"#44a6c6\") +\n  geom_node_text(aes(label = name), fontface = \"bold\") +\n  scale_edge_color_continuous(low = \"grey66\", high = \"black\") +\n  scale_edge_width(range = c(0.1, 0.5)) +\n  theme_graph() +\n  coord_fixed()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nUsing \"stress\" as default layout\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/unreadable_labels-1.png){width=768}\n:::\n:::\n\n\nHere you can make use of the fact that the layout of the nodes are stored in a \"hidden\" data frame when a `ggraph` object is constructed (this is what we made use of with `geom_mark_hull()` too). That means you can use other geoms from other packages. In this case, the `shadowtext` package as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(g,\"stress\") +\n  geom_edge_link0(aes(edge_color = weight, edge_width = weight), show.legend = FALSE) +\n  geom_node_point(size = 8, color = \"#44a6c6\") +\n  shadowtext::geom_shadowtext(aes(x, y, label = name), color = \"black\", size = 4, bg.colour = \"white\") +\n  scale_edge_color_continuous(low = \"grey66\", high = \"black\") +\n  scale_edge_width(range = c(0.1, 0.5)) +\n  theme_graph() +\n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](07-netviz-2_files/figure-html/shadowtext_labels-1.png){width=768}\n:::\n:::\n",
    "supporting": [
      "07-netviz-2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../../../site_libs/vis-9.1.0/vis-network.min.css\" rel=\"stylesheet\" />\n<script src=\"../../../../site_libs/vis-9.1.0/vis-network.min.js\"></script>\n<script src=\"../../../../site_libs/visNetwork-binding-2.1.2/visNetwork.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}