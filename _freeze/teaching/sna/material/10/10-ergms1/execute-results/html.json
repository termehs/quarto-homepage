{
  "hash": "ea38adced2de5ef12590fd2e96ceab5f",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor:  Termeh Shafie\ntitle: \"Social Network Analysis\"\nsubtitle: \"Worksheet 10: ERGMs I\"\nlightbox: auto\ntoc: true\nformat:\n  html:\n    embed-resources: true\n    fig-width: 10\n    fig-height: 10\nexecute: \n  cache: true\n---\n\n# Introduction\n\nWe're going to follow the ERGM modelling outline:\n\n-   specify and estimate model parameters that should govern evolution of network\n-   simulate other random networks based on specified models\n-   compare the goodness of fit of observed to model networks.\n\nThe following resource is useful for looking up different model terms: [ERGM terms](https://cran.r-project.org/web/packages/ergm/vignettes/ergm-term-crossRef.html).\n\nNote that we now are performing stochastic simulation -- in some of the cases, your output will differ slightly from mine and between different runs (you can however use `set.seed()` to get exactly the same results).\n\n\n\n## Packages needed\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(statnet) # also loads the ERGM package\nlibrary(igraph)\nlibrary(ggraph)\nlibrary(intergraph)\nlibrary(patchwork)\nlibrary(networkdata)\n```\n:::\n\n\n## Object types\n\nWe will be primarily be working with matrix, network and graph objects. Note that `ergm` primarily requires network and adjacency matrices, but since we will be using `ggraph` to visualize networks we also need graph objects. We try to keep it clear here by using suffix *g*, *net* and *mat* to clarify object assignment.\n\n# Florentine marriage network\n\nWe start by loading the Florentine marriage network (available in the `statnet` package) and create the adjacency matrix from the loaded network object. This is done with the below code. Note that we have some available node attributes: priorates, totalties, vertex.names and wealth. We'll be using these attributes later for modeling ERGMs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(florentine) # loads flomarriage and flobusiness data\nflom_net <- flomarriage # look at the flomarriage network data\nflom_mat <- as.matrix(flomarriage)\n```\n:::\n\n\nTo visualize the network we create a graph object (note that using `geom_node_text` includes the vertex/family names but you can exclude this if you prefer):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflom_g <- asIgraph(flom_net)\nflom_p <- ggraph(flom_g, layout = \"stress\") + \n  geom_edge_link0(edge_colour = \"#666060\", \n                  edge_width = 0.8, edge_alpha = 1) +\n  geom_node_point(fill = \"#808080\", colour = \"#808080\",  \n                  size = 7, shape = 21, stroke = 0.9) +\n  theme_graph() + \n  theme(legend.position = \"none\") +\n  geom_node_text(aes(label = vertex.names), colour = \"#000000\",\n    size = 5, family = \"sans\") +\n  ggtitle(\"Florentine marriage network\")\nflom_p\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-3-1.png){width=864}\n:::\n:::\n\n\n## Model 1: Dyadic independence/Bernoulli graph\n\n### Estimation\n\nWe begin by specifying a Bernoulli model using the `ergm` function. This is done by only including number of edges as a term in the model (recall from lecture that this implies dyadic independence). Run the model and print out summary of model fit using below code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflom_mod1 <- ergm(flom_net ~ edges) # fit the model\nsummary(flom_mod1) # get a summary of model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nergm(formula = flom_net ~ edges)\n\nMaximum Likelihood Results:\n\n      Estimate Std. Error MCMC % z value Pr(>|z|)    \nedges  -1.6094     0.2449      0  -6.571   <1e-04 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n     Null Deviance: 166.4  on 120  degrees of freedom\n Residual Deviance: 108.1  on 119  degrees of freedom\n \nAIC: 110.1  BIC: 112.9  (Smaller is better. MC Std. Err. = 0)\n```\n\n\n:::\n:::\n\n\nYou can also just print the estimated coefficient using only `flom_mod1`.\n\n**Q1**. How can you interpret the parameter estimate?\n\nThe log-odds of any tie occurring is: $$ -1.609 \\times \\textrm{change in the number of ties} = -1.609 \\times 1 $$ for all ties, since the addition of any tie to the network changes the number of ties by 1. Corresponding probability is: $$\\frac{\\exp{(-1.609)}}{1+\\exp{(-1.609)}}=0.1667$$ which is what you would expect, since there are 20/120 ties.\n\n## Model 2: Transitivity effect added\n\n### Estimation\n\nNext, we add a term the number of completed triangles/triads (which would indicate **transitivity**).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1) #include if you want the same results shown here\nflom_mod2 <- ergm(flom_net ~ edges + triangle)\nsummary(flom_mod2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nergm(formula = flom_net ~ edges + triangle)\n\nMonte Carlo Maximum Likelihood Results:\n\n         Estimate Std. Error MCMC % z value Pr(>|z|)    \nedges     -1.6913     0.3219      0  -5.254   <1e-04 ***\ntriangle   0.1808     0.5567      0   0.325    0.745    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n     Null Deviance: 166.4  on 120  degrees of freedom\n Residual Deviance: 108.1  on 118  degrees of freedom\n \nAIC: 112.1  BIC: 117.6  (Smaller is better. MC Std. Err. = 0.01061)\n```\n\n\n:::\n:::\n\n\n**Q2** How can you interpret the parameter estimates?\n\n**Q3** What do the parameter estimates tell us about the configurations specified in the model?\n\nConditional log-odds of two actors forming a tie is:\n\n-   $-1.644\\times$ change in the number of ties + $0.134 \\times$ change in number of triangles\n-   if the tie will not add any triangles to the network, its log-odds is: -1.644\n-   if it will add one triangle to the network, its log-odds is: -1.644 + 0.134\n-   if it will add two triangles to the network, its log-odds is: -1.644 + 0.134 $\\times$ 2\n\n### MCMC diagnostics\n\nYou can use `mcmc.diagnostics(flom_mod2)` to observe the behavior of the MCMC estimation algorithm and check for degeneracy. What you want to see in the MCMC diagnostics: the MCMC sample statistics varying randomly around the observed values at each step in the trace plots (which means the chain is mixing well) and the difference between the observed and simulated values of the sample statistics should have a roughly bell-shaped distribution, centered at 0 (which means no difference):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc.diagnostics(flom_mod2, center = TRUE)\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSample statistics summary:\n\nIterations = 14336:262144\nThinning interval = 1024 \nNumber of chains = 1 \nSample size per chain = 243 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n           Mean    SD Naive SE Time-series SE\nedges    0.2058 4.957   0.3180         0.3180\ntriangle 0.2222 2.866   0.1839         0.1839\n\n2. Quantiles for each variable:\n\n         2.5% 25% 50% 75% 97.5%\nedges      -9  -3   0   4  9.95\ntriangle   -3  -2   0   1  7.95\n\n\nAre sample statistics significantly different from observed?\n               edges  triangle    (Omni)\ndiff.      0.2057613 0.2222222        NA\ntest stat. 0.6471018 1.2086209 1.6694087\nP-val.     0.5175661 0.2268085 0.4367585\n\nSample statistics cross-correlations:\n             edges  triangle\nedges    1.0000000 0.7771561\ntriangle 0.7771561 1.0000000\n\nSample statistics auto-correlation:\nChain 1 \n                edges    triangle\nLag 0     1.000000000  1.00000000\nLag 1024  0.056425983 -0.04043396\nLag 2048  0.006273791  0.01940035\nLag 3072 -0.051649675 -0.02455474\nLag 4096 -0.034487041  0.02913158\nLag 5120 -0.023329356  0.01178056\n\nSample statistics burn-in diagnostic (Geweke):\nChain 1 \n\nFraction in 1st window = 0.1\nFraction in 2nd window = 0.5 \n\n   edges triangle \n1.458524 1.483872 \n\nIndividual P-values (lower = worse):\n    edges  triangle \n0.1446962 0.1378428 \nJoint P-value (lower = worse):  0.1011719 \n\nNote: MCMC diagnostics shown here are from the last round of\n  simulation, prior to computation of final parameter estimates.\n  Because the final estimates are refinements of those used for this\n  simulation run, these diagnostics may understate model performance.\n  To directly assess the performance of the final model on in-model\n  statistics, please use the GOF command: gof(ergmFitObject,\n  GOF=~model).\n```\n\n\n:::\n:::\n\n\n**Q4** How would you interpret these results?\n\n### Simulation\n\nWhen we have estimated the coefficients of an ERGM, we have defined a probability distribution across all networks of the same size. If the model is a good fit to the observed data, networks drawn from this distribution resemble the observed data. To draw networks from this distribution we use the `simulate()` function. We draw ten networks from the specified model and use the below command to get a summary of what the network statistics `edges` and `triangles` are for each of the ten sampled networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflom_mod2.sim <- simulate(flom_mod2, nsim = 10)\nsummary(flom_mod2.sim)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of Networks: 10 \nModel: flom_net ~ edges + triangle \nReference: ~Bernoulli \nConstraints: ~. ~. - observed \nStored network statistics:\n      edges triangle\n [1,]    16        3\n [2,]    26        7\n [3,]    18        1\n [4,]    17        1\n [5,]    22        1\n [6,]    18        1\n [7,]    11        1\n [8,]    22        4\n [9,]    20        3\n[10,]    26        6\nattr(,\"monitored\")\n[1] FALSE FALSE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of Networks: 10 \nModel: flom_net ~ edges + triangle \nReference: ~Bernoulli \nConstraints: ~. ~. - observed \n```\n\n\n:::\n:::\n\n\nThis should give you a list over the ten networks and columns representing how many edges and triangles are apparent in each simulated case. Since you have listed all the simulated networks, you can simply call each one of them individually. For example, in the below, we call simulated networks 1 and 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflom_mod2.sim[[1]]\nflom_mod2.sim[[2]]\n```\n:::\n\n\nYou can also choose one of the networks to visualize, below is an example for the tenth, i.e. last on the list of, simulated network:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflom.sim_g <-asIgraph(flom_mod2.sim[[10]])\nflom.sim_p <- ggraph(flom.sim_g, layout = \"stress\") + \n  geom_edge_link0(edge_colour = \"#666060\", \n                  edge_width = 0.8, edge_alpha = 1) +\n  geom_node_point(fill = \"#808080\", colour = \"#808080\",  \n                  size = 7, shape = 21, stroke = 0.9) +\n  theme_graph() + \n  theme(legend.position = \"none\") +\n  ggtitle(\"Simulated network\")\nflom.sim_p\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-9-1.png){width=864}\n:::\n:::\n\n\nThese simulations are crucial for examining the goodness of fit which we will do next.\n\n### 3. Goodness of Fit\n\nThe MCMC algorithm draws a dyad at random at each step, and evaluates the probability of a tie from the perspective of these two nodes. That probability is governed by the ergm-terms specified in the model, and the current estimates of the coefficients on these terms. Once the estimates converge, simulations from the model will produce networks that are centered on the observed model statistics i.e. those we control for (otherwise it is a sign that something has gone wrong in the estimation process). The networks will also have other emergent global properties that are not represented by explicit terms in the model. Thus, goodness of fit can be done in two ways, where the first is to be preferred:\n\n-   evaluate the fit to the specified terms in the model (done by default)\n\n-   evaluate the fit of terms not specified in the model to emergent global network properties\n\nIf the first does not indicate something off in the estimation process, you can use the second where three terms that can be used to evaluate the fit to emergent global network properties:\n\n1.  the node level (degree)\n\n2.  the edge level (esp: edgewise share partners)\n\n3.  the dyad level (geodesic distances)\n\nWe check now whether the specified model above fits the observed data and how well it reproduces it. We do this by choosing a network statistic (that is not specified in the model), and comparing the value of this statistic to the distribution of values we get in simulated networks from our model. We use the `gof()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflom_mod2.gof <- gof(flom_mod2) # this will produce 4 plots\npar(mfrow=c(2,2)) # figure orientation with 2 rows and 2 columns\nplot(flom_mod2.gof) # gof plots\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nTo get an output containing the summary of the gof:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflom_mod2.gof # summary output of gof\n```\n:::\n\n\n**Q5** How would you interpret the goodness of fit here?\n\n# Lazega's lawyers (from lecture)\n\nWe will use the same subset of this network as in the previous lab: we want to check whether or not the *partners* of the firm more frequently work together with other partners having the same practice. We import the data as a graph object from the `networkdata` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"law_cowork\")\n```\n:::\n\n\nWe then create an adjacency matrix from the directed graph for the first 36 lawyers in the network corresponding to the partners of the firm (see attribute 'status'). To test homophily now, we only consider the reciprocal ties so we need to symmetrize the matrix to create and undirected graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlaw_mat_cwdir <- as_adjacency_matrix(law_cowork, sparse = FALSE)\nlaw_mat_cwdir <- law_mat_cwdir[1:36,1:36]\nlaw_mat_cw <- (law_mat_cwdir == t(law_mat_cwdir) & law_mat_cwdir ==1) + 0\n```\n:::\n\n\nNext we save the binary attribute 'practice' (1 = litigation, 2 = corporate) from the graph object as a vector, which is then in turn converted into a data frame (again only for the first 36 lawyers who are partners):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlaw_attr.pract <- vertex_attr(law_cowork)$pract[1:36] - 1\n```\n:::\n\n\nSince observed attribute values are 1/2, we subtract 1 to get a 0/1 variable which is easier to interpret in an ERGM context.\n\nWe create a network object and add the node attribute 'practice':\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlaw_net <- as.network(law_mat_cw, directed = FALSE) \nlaw_net %v% \"practice\" <- law_attr.pract\nlaw_net\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Network attributes:\n  vertices = 36 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 115 \n    missing edges= 0 \n    non-missing edges= 115 \n\n Vertex attribute names: \n    practice vertex.names \n\nNo edge attributes\n```\n\n\n:::\n:::\n\n\n## Model 1: homophily and clustering\n\n### Estimation\n\nWe are interested in running an ERGM with the following statistics (as done during lecture)\n\n-   nodecov(\"practice\")\n\n-   match(\"practice\")\n\n-   gwesp(decay = 0.693)\n\n**Q6** Can you recall what these statistics represent? To run the ERGM:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlaw_mod1 <- ergm(law_net ~ edges\n  + nodecov(\"practice\") + match(\"practice\")\n  + gwesp(0.693, fixed = TRUE)\n)\nsummary(law_mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nergm(formula = law_net ~ edges + nodecov(\"practice\") + match(\"practice\") + \n    gwesp(0.693, fixed = TRUE))\n\nMonte Carlo Maximum Likelihood Results:\n\n                   Estimate Std. Error MCMC % z value Pr(>|z|)    \nedges              -4.38591    0.32189      0 -13.626  < 1e-04 ***\nnodecov.practice    0.18221    0.07121      0   2.559 0.010498 *  \nnodematch.practice  0.60364    0.16760      0   3.602 0.000316 ***\ngwesp.fixed.0.693   1.14125    0.16112      0   7.083  < 1e-04 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n     Null Deviance: 873.4  on 630  degrees of freedom\n Residual Deviance: 503.4  on 626  degrees of freedom\n \nAIC: 511.4  BIC: 529.2  (Smaller is better. MC Std. Err. = 0.3047)\n```\n\n\n:::\n:::\n\n\nSee lecture slides for the interpretation of these coefficients.\n\n### MCMC diagnostics\n\nCheck the model by running MCMC diagnostics to observe what is happening with the simulation algorithm:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc.diagnostics(law_mod1, center = TRUE)\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSample statistics summary:\n\nIterations = 122880:2424832\nThinning interval = 2048 \nNumber of chains = 1 \nSample size per chain = 1125 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n                    Mean    SD Naive SE Time-series SE\nedges              3.588 30.18   0.8997          2.050\nnodecov.practice   1.178 29.10   0.8677          1.771\nnodematch.practice 2.573 18.51   0.5520          1.187\ngwesp.fixed.0.693  6.930 59.05   1.7605          4.047\n\n2. Quantiles for each variable:\n\n                     2.5%    25%  50%   75% 97.5%\nedges               -70.0 -14.00  8.0 25.00  49.0\nnodecov.practice    -75.0 -12.00  6.0 21.00  43.9\nnodematch.practice  -41.8  -8.00  4.0 15.00  33.0\ngwesp.fixed.0.693  -132.5 -27.95 12.5 49.26 101.6\n\n\nAre sample statistics significantly different from observed?\n                edges nodecov.practice nodematch.practice gwesp.fixed.0.693\ndiff.      3.58755556        1.1777778         2.57333333        6.93039339\ntest stat. 1.74979703        0.6652089         2.16772023        1.71264367\nP-val.     0.08015334        0.5059169         0.03017998        0.08677811\n                 (Omni)\ndiff.                NA\ntest stat. 1.890437e+01\nP-val.     9.736672e-04\n\nSample statistics cross-correlations:\n                       edges nodecov.practice nodematch.practice\nedges              1.0000000        0.8720346          0.9463973\nnodecov.practice   0.8720346        1.0000000          0.8292965\nnodematch.practice 0.9463973        0.8292965          1.0000000\ngwesp.fixed.0.693  0.9942961        0.8753042          0.9426539\n                   gwesp.fixed.0.693\nedges                      0.9942961\nnodecov.practice           0.8753042\nnodematch.practice         0.9426539\ngwesp.fixed.0.693          1.0000000\n\nSample statistics auto-correlation:\nChain 1 \n              edges nodecov.practice nodematch.practice gwesp.fixed.0.693\nLag 0     1.0000000       1.00000000          1.0000000         1.0000000\nLag 2048  0.7091548       0.61237659          0.6442048         0.6814578\nLag 4096  0.4717707       0.37544290          0.4192158         0.4478894\nLag 6144  0.3156917       0.22673439          0.2935639         0.2997408\nLag 8192  0.2111325       0.13342547          0.1785633         0.2016442\nLag 10240 0.1487237       0.07132966          0.1299507         0.1454400\n\nSample statistics burn-in diagnostic (Geweke):\nChain 1 \n\nFraction in 1st window = 0.1\nFraction in 2nd window = 0.5 \n\n             edges   nodecov.practice nodematch.practice  gwesp.fixed.0.693 \n          1.493081           0.917114           1.500024           1.640398 \n\nIndividual P-values (lower = worse):\n             edges   nodecov.practice nodematch.practice  gwesp.fixed.0.693 \n         0.1354159          0.3590829          0.1336083          0.1009225 \nJoint P-value (lower = worse):  0.005343654 \n\nNote: MCMC diagnostics shown here are from the last round of\n  simulation, prior to computation of final parameter estimates.\n  Because the final estimates are refinements of those used for this\n  simulation run, these diagnostics may understate model performance.\n  To directly assess the performance of the final model on in-model\n  statistics, please use the GOF command: gof(ergmFitObject,\n  GOF=~model).\n```\n\n\n:::\n:::\n\n\n**Q6** Do you see any problems with model degeneracy here? Is the estimation process working as it should?\n\n### Goodness of Fit\n\nGoodness of fit can be checked as done earlier:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlaw_mod1.gof <- gof(law_mod1) # this will produce 4 plots\npar(mfrow = c(2, 2)) # figure orientation with 2 rows and 2 columns\nplot(law_mod1.gof)\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nNote that you should not use `esp` to assess goodness of fit since it was explicitly modeled via the `gwesp` term in the specified model.\n\n# Knecht's Friendship Network\n\nFor the last part, we will fir an ERGM to a directed network to check for reciprocity. We use a friendship network (Knecht,2008) which can be loaded using the `networkdata` package. You can read about the network by typing `?knecht`. Note that the network is longitudinal and observed over four time periods. We will here focus on the last time period. To load the wave 4 data and to visualize it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"knecht\")\nknecht4_g <- knecht[[4]]\nknecht4_p <- ggraph(knecht4_g, layout = \"stress\") + \n  geom_edge_link(edge_colour = \"#666060\", end_cap = circle(9,\"pt\"), \n                         n = 2, edge_width = 0.4, edge_alpha = 1, \n                         arrow = arrow(angle = 15, \n                         length = unit(0.1, \"inches\"), \n                         ends = \"last\", type = \"closed\"))  +\n  geom_node_point(fill = \"#000000\", colour = \"#000000\", \n                  size = 7, shape = 21, stroke = 0.9) +\n  theme_graph() + \n  theme(legend.position = \"none\") +\n  ggtitle(\"Observed network (wave 4)\")\nknecht4_p\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-19-1.png){width=768}\n:::\n:::\n\n\nNext we create the network object to fit ERGMs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  # to create network objects\nknecht4_net <- asNetwork(knecht[[4]])\n```\n:::\n\n\n## Model 1: Reciprocity effect\n\n### Estimation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknecht4_mod1 <- ergm(knecht4_net ~ edges + mutual)\nsummary(knecht4_mod1) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nergm(formula = knecht4_net ~ edges + mutual)\n\nMonte Carlo Maximum Likelihood Results:\n\n       Estimate Std. Error MCMC % z value Pr(>|z|)    \nedges   -2.1889     0.1450      0 -15.100   <1e-04 ***\nmutual   2.4115     0.3212      0   7.507   <1e-04 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n     Null Deviance: 901.1  on 650  degrees of freedom\n Residual Deviance: 562.9  on 648  degrees of freedom\n \nAIC: 566.9  BIC: 575.8  (Smaller is better. MC Std. Err. = 0.7652)\n```\n\n\n:::\n:::\n\n\n**Q7** How do you interpret these results?\n\n### MCMC diagnostics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc.diagnostics(knecht4_mod1)\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSample statistics summary:\n\nIterations = 14336:262144\nThinning interval = 1024 \nNumber of chains = 1 \nSample size per chain = 243 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n          Mean     SD Naive SE Time-series SE\nedges  -1.0988 11.869   0.7614         0.9010\nmutual -0.3333  5.357   0.3436         0.4182\n\n2. Quantiles for each variable:\n\n         2.5%  25% 50% 75% 97.5%\nedges  -26.00 -9.5   0   7    19\nmutual -10.95 -4.0   0   3    11\n\n\nAre sample statistics significantly different from observed?\n                edges     mutual    (Omni)\ndiff.      -1.0987654 -0.3333333        NA\ntest stat. -1.2194889 -0.7970729 1.8580854\nP-val.      0.2226587  0.4254087 0.3982094\n\nSample statistics cross-correlations:\n           edges    mutual\nedges  1.0000000 0.8121613\nmutual 0.8121613 1.0000000\n\nSample statistics auto-correlation:\nChain 1 \n               edges      mutual\nLag 0     1.00000000  1.00000000\nLag 1024  0.16476519  0.19190028\nLag 2048 -0.03275616 -0.03862647\nLag 3072 -0.04234861 -0.10047043\nLag 4096  0.03109986  0.06411610\nLag 5120  0.05887512  0.04907514\n\nSample statistics burn-in diagnostic (Geweke):\nChain 1 \n\nFraction in 1st window = 0.1\nFraction in 2nd window = 0.5 \n\n      edges      mutual \n-0.09833024 -0.92194343 \n\nIndividual P-values (lower = worse):\n    edges    mutual \n0.9216701 0.3565581 \nJoint P-value (lower = worse):  0.3677926 \n\nNote: MCMC diagnostics shown here are from the last round of\n  simulation, prior to computation of final parameter estimates.\n  Because the final estimates are refinements of those used for this\n  simulation run, these diagnostics may understate model performance.\n  To directly assess the performance of the final model on in-model\n  statistics, please use the GOF command: gof(ergmFitObject,\n  GOF=~model).\n```\n\n\n:::\n:::\n\n\n**Q8** How do you interpret these results?\n\n### Goodness of fit\n\nNote that since we now are considering a directed network, we need to separate in- and out-degree when assessing the goodness of fit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknecht4_mod1.gof <- gof(knecht4_mod1) # this will produce 4 plots\npar(mfrow = c(3,2)) # figure orientation with 2 rows and 2 columns\nplot(knecht4_mod1.gof)\n```\n\n::: {.cell-output-display}\n![](10-ergms1_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n**Q9** How do you interpret these results?\n\n## Model 2: Reciprocity and homophily effect\n\nNow we also include a homophily effect, i.e. do students tend to befriend others of the same gender?\n\n**Q10** Run the usual steps of fitting and ERGM, checking the estimation algorithm and assessing the goodness of fit. The ERGM syntax is shown below. What can you conclude?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknecht4_mod2 <- ergm(knecht4_net ~ edges +  nodecov(\"gender\") + \n                       nodematch(\"gender\") + mutual)\nsummary(knecht4_mod2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nergm(formula = knecht4_net ~ edges + nodecov(\"gender\") + nodematch(\"gender\") + \n    mutual)\n\nMonte Carlo Maximum Likelihood Results:\n\n                 Estimate Std. Error MCMC % z value Pr(>|z|)    \nedges             -4.1981     0.3843      0 -10.925   <1e-04 ***\nnodecov.gender     0.4966     0.1192      0   4.167   <1e-04 ***\nnodematch.gender   1.2061     0.2257      0   5.344   <1e-04 ***\nmutual             2.0843     0.3735      0   5.580   <1e-04 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n     Null Deviance: 901.1  on 650  degrees of freedom\n Residual Deviance: 520.4  on 646  degrees of freedom\n \nAIC: 528.4  BIC: 546.3  (Smaller is better. MC Std. Err. = 0.8236)\n```\n\n\n:::\n:::\n\n\n# Exercises\n\n**Exercise 1** Use the undirected cowork network of the lawyer data.\n\n**(a)** Focus on the attribute 'gender' now. Fit an ERGM that potentially could answer whether or not the *partners* of the firm more frequently work together with other partners of the same gender.\n\n**(b)** Focus now instead on *all* 71 lawyers of the data and fit an ERGM that potentially could answer whether or not the *partners* of the firm more frequently work together with other partners of the firm.\n\n**(c)** Can you understand why maximum pseudolikelihood estimation (MPLE) is used when only including `nodecov()` and `match()` terms?\n\n**Exercise 2:** Import the data on Kapferer's Tailors from the package `networkdata`. You can read about the data by typing `?mine`. Note that the data is imported as graph objects so to convert it to a network object, type the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmine_net <- asNetwork(mine)\n```\n:::\n\n\nPerform the following tasks:\n\n**(a)** Fit en ERGM with edges and triangles included. How do you interpret the coefficients?\n\n**(b)** Run MCMC diagnostics on the model in (a). Do you not any problems in the estimation process?\n\n**(c)** Perform a goodness of fit assessment on the model in (a). What can you conclude?\n\n**Exercise 3:** Use the directed Knecht friendship networks for this exercise.\n\n**(a)** We wish to compare the reciprocity effect from wave 1 to wave 4. We fitted the ERGM for wave 4 above. Run the same ERGM for wave 1 and run the usual checks of the fitted model. Can you notice a difference in reciprocity over time?\n\n**(b)** Run the same comparison as in (a) but also include gender homophily in your model specification. Can you notice a difference in the effects from wave 1 to wave 4?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}