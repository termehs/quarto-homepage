{
  "hash": "d41d9e660a89b3986963fa04d09882e0",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor:  Termeh Shafie\ntitle: \"Social Network Analysis\"\nsubtitle: \"Worksheet 3: Network Concepts and Descriptives I\"\nlightbox: auto\ntoc: true\nformat:\n  html:\n    embed-resources: true\n    fig-width: 10\n    fig-height: 10\n---\n\n\n### Load Packages\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(igraph)\nlibrary(networkdata)\nlibrary(netUtils)\n```\n:::\n\n\n### To start off...\nLoad the following two datasets\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"tailor_social\")\ndata(\"tailor_work\")\n```\n:::\n\n\n**Which of the two networks is directed and how can you verify this?** \n\n**Solution**\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# print both and check for `--` and `->` edges or \"UN\" and \"DN\"\ntailor_social\ntailor_work\n\n#str from netUtils prints the type explicitly\nstr(tailor_social)\nstr(tailor_work)\n\nis_directed(tailor_social)\nis_directed(tailor_work)\n```\n:::\n\n\n### Exercise: Reading network data\n\n- load all network files in `data.zip` into R and create appropriate igraph objects\n- calculate the density of the networks\n- calculate local and global transitivity (if possible)\n- check if the global transitivity differs from a random graph (see slide 60; choose one network or all)  \n\n**Solution**\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n#net1\ntab <- read.csv(\"data/net1.csv\",header = TRUE,row.names = 1,sep = \" \")\nclass(tab)\nA <- as.matrix(tab)\ngraph_from_adjacency_matrix(A)\n#check if the matrix is symmetric\nA == t(A)\n\nnet1 <- graph_from_adjacency_matrix(A,mode = \"undirected\",weighted = TRUE,diag = FALSE)\n\n#net2\ntab <- read.csv(\"data/net2.csv\",header = TRUE, sep = \",\")\n#graph_from_edgelist(tab)\nel <- as.matrix(tab)\nnet2 <- graph_from_edgelist(el,directed = FALSE)\n\n#net3\ntab <- read.csv(\"data/net3.csv\",header = TRUE, sep=\"\\t\")\nel <- as.matrix(tab)\nnet3 <- graph_from_edgelist(el[,1:2],directed = FALSE)\n\nE(net3)$weight <- tab[,3]\nnet3 <- set_edge_attr(net3,name = \"weight\",value = tab[,3])\n\n#net4\ntab <- read.csv(\"data/net4.csv\",header = TRUE,row.names = 1,sep = \",\")\nclass(tab)\nA <- as.matrix(tab)\n#check if the matrix is symmetric\nA == t(A)\nnet4 <- graph_from_adjacency_matrix(A,mode = \"directed\",weighted = TRUE,diag = FALSE)\n\n#net5\ntab <- read.csv(\"data/net5.csv\",header = TRUE,row.names = 1,sep = \"\\t\")\nclass(tab)\nA <- as.matrix(tab)\n\n#check if the matrix is symmetric\nA == t(A)\nnet5 <- graph_from_adjacency_matrix(A,mode = \"directed\",weighted = TRUE,diag = FALSE)\n```\n:::\n\n\n\n### Netreader Addin\n*(Interactive Session)*\n\n### Exercise: Create networks\n\nTry to create igraph objects for the following networks:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](03-descriptives-1_files/figure-html/examples_to_built_sols-1.png){width=1440}\n:::\n:::\n\n\n\n\nChoose one network (you can also do more) and do the following:\n\n- add `names` as a node attribute\n- add an edge attribute `weight` and assign it values of your choice\n- find a way to extract the edgelist and the adjacency matrix of the networks\n\n\n**Solution**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\nlibrary(patchwork)\nlibrary(ggraph)\ng1 <- make_full_graph(5)\nV(g1)$name <- LETTERS[1:5]\n#g1 <- graph_from_literal(A:B:C:D:E -- A:B:C:D:E)\n\np1 <- ggraph(g1,\"stress\")+\n   geom_edge_link0()+\n   geom_node_point(shape=21,fill=\"grey66\",size=10)+\n   geom_node_text(aes(label=name), size = 7)\n\ng2 <- make_graph(edges = c(\"A\",\"B\",\"B\",\"C\"))\n#g2 <- graph_from_literal( A -+ B -+ C )\n#g2 <- make_ring(3,directed = TRUE,circular = FALSE)\n\np2 <- ggraph(g2,\"stress\")+\n   geom_edge_link(arrow = arrow(angle = 15, length = unit(0.15, \"inches\"), ends = \"last\", type = \"closed\"),end_cap=circle(12,\"pt\"),n=2)+\n   geom_node_point(shape=21,fill=\"grey66\",size=10)+\n   geom_node_text(aes(label=name), size= 7)\n\ng3 <- make_star(5,\"undirected\",center = 3)\nV(g3)$name <- 1:5\np3 <- ggraph(g3,\"stress\")+\n   geom_edge_link0()+\n   geom_node_point(shape=21,fill=\"grey66\",size=10)+\n   geom_node_text(aes(label=name), size = 7)\n\np1 + p2 + p3\n```\n:::\n\n\n\n\n## Structural features \n\n### Exercise: Degree Distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa <- sample_pa(1500, power = 1.5, m = 3, directed = FALSE)\ner <- sample_gnp(1500, p = 0.003)\n```\n:::\n\n\n- Verify that the networks have approximately the same density\n- Plot the degree distributions of both networks and check for skewness\n- calculate the degrees (`degree()`) and order the sequence decreasingly (`order()`) \n- For both networks, create a loop (i=1,..., 50) which deletes the top i vertices (`delete_vertices()`) in the ordered degree sequence and compute the diameter of the resulting networks\n- What can you observe?\n\n**Solution**\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n#calculate the density (edge_density is the same as graph.density)\nedge_density(pa)\nedge_density(er)\n\n# for the preferential attachment network, \n# we plot the degree distribution on a log-log scale\n# a straight-ish line should appear \nplot(degree_distribution(pa), log=\"xy\")\nplot(degree_distribution(er))\n\n#calculate the degrees explicitly\ndeg_er <- order(degree(er),decreasing = TRUE)\ndeg_pa <- order(degree(pa),decreasing = TRUE)\n\n# iterate through the top 50 nodes, delete them and calculate the diameter\nres_er <- rep(0,50)\nres_pa <- rep(0,50)\n\nfor(i in 1:50){\n  g1 <- delete_vertices(er,deg_er[1:i])\n  g2 <- delete_vertices(pa,deg_pa[1:i])\n  res_er[i] <- diameter(g1)\n  res_pa[i] <- diameter(g2)\n}\n\nplot(res_pa,type = \"l\", col=\"red\",ylab=\"diameter\")\nlines(res_er,col=\"black\")\n```\n:::\n\n\nYou'll notice that the diameter increases very quickly for a preferential attachment network. The diameter of the random network on the other hand remains constant. If you would redo the analysis for the preferential attachment network and remove random nodes, you'll notice that the diameter also remains constant. A preferential network is thus said to be **fragile to targeted attacks** but **robust to random attacks**. \n\n### Exercise: Density, Transitivity, Distances\n\nReal world networks tend to have a high transitivity (`transitivity(type=\"global\")`), low average distance (`mean_distance()`) and a low density (`graph.density()`). \n\n- Experiment with `sample_pa()` and `sample_gnp()` and compute the three stats. Can all three criteria be fullfiled? Why/why not?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Hint\"}\n# Parameters\nn <- 1000       # number of nodes\nm <- 5          # edges per new node in PA\np <- 0.01       # connection probability for GNP\n\n# Preferential Attachment \ng_pa <- sample_pa(n, power = 1, m = m, directed = FALSE)\n\n# Erdős–Rényi (GNP)\ng_gnp <- sample_gnp(n, p, directed = FALSE)\n\n# Compute statistics\ncompute_stats <- function(graph) {\n  trans <- transitivity(graph, type = \"global\")\n  dist <- mean_distance(graph, directed = FALSE, unconnected = TRUE)\n  dens <- edge_density(graph)\n  return(c(transitivity = trans, mean_distance = dist, density = dens))\n}\n\n# Get stats\nstats_pa <- compute_stats(g_pa)\nstats_gnp <- compute_stats(g_gnp)\n\n# Combine into a data frame\nresults <- data.frame(\n  Model = c(\"Preferential Attachment\", \"Erdős–Rényi (GNP)\"),\n  Transitivity = c(stats_pa[\"transitivity\"], stats_gnp[\"transitivity\"]),\n  Mean_Distance = c(stats_pa[\"mean_distance\"], stats_gnp[\"mean_distance\"]),\n  Density = c(stats_pa[\"density\"], stats_gnp[\"density\"])\n)\n\nresults\n```\n:::",
    "supporting": [
      "03-descriptives-1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}