{
  "hash": "79eece5f1692cdfc7415e22d1ae57fe2",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor:  Termeh Shafie\ntitle: \"Social Network Analysis\"\nsubtitle: \"Worksheet 5a: Beyond 'Standard' Networks ^[This worksheet is inspired and adapted from [this source](https://inarwhal.github.io/NetworkAnalysisR-book/ch6-Ego-Network-Data-R.html)]\"\nlightbox: auto\ntoc: true\nformat:\n  html:\n    embed-resources: true\n    fig-width: 10\n    fig-height: 10\n---\n\n# Ego Networks\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(egor)\nlibrary(igraph)\nlibrary(tidyverse)\nlibrary(patchwork)\n```\n:::\n\n\nIn this practical we will\n\n- begin by covering the basics of ego network data, utilizing the `egor` package  to manipulate, construct and visualize ego networks  \n- focus on analyzing substantive questions related to homophily, the tendency for similar actors to interact at higher rates than dissimilar actors, on different demographic dimensions.\n-  consider an example where the ego network properties are used to predict other outcomes of interest, like happiness\n\n## Data \nThe example ego network data come from the 1985 General Social Survey (GSS), a national survey of American adults done face-to-face. The aim of the surveys are to \n\n- track changes in social attitudes, behaviors, and attributes over time\n- measure opinions on a wide range of social issues like race, religion, politics, crime, work, and family.\n- provide data for social science research \n\nWe work with ego network data from the GSS that has been preprocessed into three different files: \n\n- a file with the ego attributes\n- a file with the alter attributes\n- a file with the alter-alter ties (1 means that the alters know each other, 2 means they are especially close)\n\nLet's go ahead and read in the three files, starting with the ego attribute data.\n\nRead in the three data file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nego_dat <- read.csv(file = \"data/gss1985_ego_dat.csv\" , stringsAsFactors = F) \nalter_dat <- read.csv(file = \"data/gss1985_alter_dat.csv\", stringsAsFactors = F)\nalteralter_dat <- read.csv(file = \"data/gss1985_alteralter_dat.csv\")\n```\n:::\n\n\n\n### Exercise 1: \nExplore the three different data sets. Do you understand the structure and content of each one? Can you see similarities and differences between the data sets? Focus specifically on these columns:\n\n::: {.cell}\n\n```{.r .cell-code}\n c(\"CASEID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"HAPPY\", \"NUMGIVEN\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\nnrow(ego_dat)\nnrow(alter_dat)\nego_dat[1:10, c(\"CASEID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"HAPPY\", \"NUMGIVEN\")]\n\n# CASEID, is the unique id for each respondent\n# for example: we can see that respondent 1 (CASEID = 19850001) names 5 alters. \n# The first alter (ALTERID = 1) is 32, has 18 years of education, and is not kin to ego. \n# NUMGIVEN is the number of alters given, there are NA's here that need to be removed\n# Note that the number of rows in the two data frames is not the same\n\nalter_dat[1:10, c(\"CASEID\", \"ALTERID\", \"AGE\", \"EDUC\", \"RACE\", \"SEX\", \"KIN\")] \n# Each row corresponds to a different named alter. \n# Each alter is denoted by an alter id (ALTERID), unique to that respondent (based on CASEID). \n# We see similar attributes as with the ego data.\n# There is also information on the relationship between ego and each alter. \n\nalteralter_dat[1:10, ]\n# this data frame captures the ties between the named alters (as reported on by the respondent)\n# We see four columns. The first column defines the relevant ego using CASEID. \n# ALTER1 defines the first alter in the dyad and ALTER2 defines the second. \n```\n:::\n\n\n\nAs noted above, there are missing values above that need to be removed:\n\n::: {.cell}\n\n```{.r .cell-code}\nego_dat <- ego_dat[!is.na(ego_dat$NUMGIVEN), ]\n```\n:::\n\n\n## Creating the network using `egor`\nFirst challenge in analyzing ego network data is that we must transform traditional survey data into something that has the structure of a network, so that we can then utilize packages like `igraph` and `sna`. Our survey data will not look like traditional network inputs (matrices, edgelists, etc.) and each survey is likely to be different, complicating the task of putting together the ego networks. \n\nLuckily, the `egor` package has made the task of constructing ego networks from survey data much easier. We will utilize the basic functionality of this package throughout the tutorial. \n\nThe `egor` function assumes that you are inputting the data using three separate files. The main arguments are:\n\n - alters = alter attributes data frame\n - egos = ego attributes data frame\n - aaties = alter-alter tie data frame\n - alter_design = list of arguments to specify nomination information from survey\n - ego_design = list of arguments to specify survey design of study\n - ID.vars = list of variable names corresponding to key columns:\n    - ego = variable name for id of ego\n    - alter = variable name for id of alter (in alter data)\n    - source = variable name for 'sender' of tie in alter-alter data\n    - target = variable name for 'receiver' of tie in alter-alter data\n\nWe will use the three data frames read in above as the main inputs. We will also tell R that CASEID is the ego id variable and ALTERID is the id variable for alters, while ALTER1 and ALTER2 are the source/target variables in the alter-alter data frame. We also note that the maximum number of alters was set to 5:\n\n\n::: {.cell}\n\n```{.r .cell-code}\negonetlist <-  egor(alters = alter_dat, egos = ego_dat, \n                    aaties = alteralter_dat, alter_design = list(max = 5), \n                    ID.vars = list(ego = \"CASEID\", alter =\"ALTERID\", \n                                   source = \"ALTER1\", target = \"ALTER2\")) \negonetlist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# EGO data (active): 1,531 × 13\n  .egoID   AGE  EDUC RACE  SEX   RELIG AGE_CATEGORICAL EDUC_CATEGORICAL NUMGIVEN\n*  <int> <int> <int> <chr> <chr> <chr> <chr>           <chr>               <int>\n1 1.99e7    33    16 white male  jewi… 30s             College                 6\n2 1.99e7    49    19 white male  cath… 40s             Post Graduate           6\n3 1.99e7    23    16 white fema… jewi… 20s             College                 5\n4 1.99e7    26    20 white fema… jewi… 20s             Post Graduate           5\n5 1.99e7    24    17 white fema… cath… 20s             Post Graduate           5\n# ℹ 1,526 more rows\n# ℹ 4 more variables: HAPPY <int>, HEALTH <int>, PARTYID <int>, WTSSALL <dbl>\n# ALTER data: 4,483 × 12\n  .altID   .egoID   AGE  EDUC RACE  SEX   RELIG AGE_CATEGORICAL EDUC_CATEGORICAL\n*  <int>    <int> <int> <dbl> <chr> <chr> <chr> <chr>           <chr>           \n1      1 19850001    32    18 white male  jewi… 30s             Post Graduate   \n2      2 19850001    29    16 white fema… prot… 20s             College         \n3      3 19850001    32    18 white male  jewi… 30s             Post Graduate   \n# ℹ 4,480 more rows\n# ℹ 3 more variables: TALKTO <int>, SPOUSE <int>, KIN <int>\n# AATIE data: 4,880 × 4\n    .egoID .srcID .tgtID WEIGHT\n*    <int>  <int>  <int>  <int>\n1 19850001      1      2      2\n2 19850001      1      3      1\n3 19850001      1      4      1\n# ℹ 4,877 more rows\n```\n\n\n:::\n:::\n\n\negor objects are constructed as tibbles, which are data frames built using the tidyverse logic. For those versed in the tidyverse, one can take advantage of all the functions, calls, etc. that go along with those kinds of objects. It is, however, not strictly necessary to know the syntax of the tidyverse to work with these objects. Let's take a look at the egor object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(egonetlist) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ego\"   \"alter\" \"aatie\"\n```\n\n\n:::\n:::\n\n\nWe see that the elements are made up of our three data frames. For example, we take the first five columns of the ego data and alter attributes, extracted from the egor object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\negonetlist[[\"ego\"]][, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,531 × 5\n     .egoID   AGE  EDUC RACE  SEX   \n      <int> <int> <int> <chr> <chr> \n 1 19850001    33    16 white male  \n 2 19850002    49    19 white male  \n 3 19850003    23    16 white female\n 4 19850004    26    20 white female\n 5 19850005    24    17 white female\n 6 19850006    45    17 white male  \n 7 19850007    44    18 white female\n 8 19850008    56    12 white female\n 9 19850009    85     7 white female\n10 19850010    65    12 white female\n# ℹ 1,521 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\negonetlist[[\"alter\"]][, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,483 × 5\n   .altID   .egoID   AGE  EDUC RACE \n    <int>    <int> <int> <dbl> <chr>\n 1      1 19850001    32    18 white\n 2      2 19850001    29    16 white\n 3      3 19850001    32    18 white\n 4      4 19850001    35    16 white\n 5      5 19850001    29    13 white\n 6      1 19850002    42    12 white\n 7      2 19850002    44    18 white\n 8      3 19850002    45    16 white\n 9      4 19850002    40    12 white\n10      5 19850002    50    18 white\n# ℹ 4,473 more rows\n```\n\n\n:::\n:::\n\n\nNote that the id variable for ego has been renamed to `.egoID` (it was `CASEID` on the original data). We also see see that the alter id has been renamed `.altID` (from `ALTERID` on the original data). \n\nAnd now we look at the alter-alter ties where we can see that the column names for the alter-alter ties have also been renamed from the input data. The variables are now `.srcID` and `.tgtID` (rather than `ALTER1` and `ALTER2`, as on the original data).\n \n\n::: {.cell}\n\n```{.r .cell-code}\negonetlist[[\"aatie\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,880 × 4\n     .egoID .srcID .tgtID WEIGHT\n      <int>  <int>  <int>  <int>\n 1 19850001      1      2      2\n 2 19850001      1      3      1\n 3 19850001      1      4      1\n 4 19850001      1      5      1\n 5 19850001      2      3      2\n 6 19850001      2      4      2\n 7 19850001      2      5      2\n 8 19850001      3      4      1\n 9 19850001      3      5      1\n10 19850001      4      5      1\n# ℹ 4,870 more rows\n```\n\n\n:::\n:::\n\n\n\n### Exercise 2:\nCalculate density on the egor object using the function `ego_density()`. Note that all ego networks of size 0 or 1 will have NAs for density).\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\ndens <- ego_density(egonetlist)\nhead(dens)\n\n# For example, respondent 1 (19850001) has 5 alters and all 10 possible ties exist \n# (density = 1), \n# while respondent 2 (1950002) has 5 alters but only 8 ties exist (density = .8). \n# To check this you can run the following:\nalteralter_dat[alteralter_dat$CASEID == 19850001, ]\nalteralter_dat[alteralter_dat$CASEID == 19850002, ]\n```\n:::\n\n\n##  Plotting the Ego Nets\nWe not plot the networks using `igraph`. First step is to convert the information in the egor object to igraph objects. We do this using the `as_igraph()` function. Let’s take a look at the first three ego networks. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nego_nets <- as_igraph(egonetlist)\nego_nets[1:3] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`19850001`\nIGRAPH 5f36126 UN-- 5 10 -- \n+ attr: .egoID (g/n), name (v/c), AGE (v/n), EDUC (v/n), RACE (v/c),\n| SEX (v/c), RELIG (v/c), AGE_CATEGORICAL (v/c), EDUC_CATEGORICAL\n| (v/c), TALKTO (v/n), SPOUSE (v/n), KIN (v/n), WEIGHT (e/n)\n+ edges from 5f36126 (vertex names):\n [1] 1--2 1--3 1--4 1--5 2--3 2--4 2--5 3--4 3--5 4--5\n\n$`19850002`\nIGRAPH 15ba0c9 UN-- 5 8 -- \n+ attr: .egoID (g/n), name (v/c), AGE (v/n), EDUC (v/n), RACE (v/c),\n| SEX (v/c), RELIG (v/c), AGE_CATEGORICAL (v/c), EDUC_CATEGORICAL\n| (v/c), TALKTO (v/n), SPOUSE (v/n), KIN (v/n), WEIGHT (e/n)\n+ edges from 15ba0c9 (vertex names):\n[1] 1--2 1--3 1--4 1--5 2--4 3--4 3--5 4--5\n\n$`19850003`\nIGRAPH d2d7e9e UN-- 5 6 -- \n+ attr: .egoID (g/n), name (v/c), AGE (v/n), EDUC (v/n), RACE (v/c),\n| SEX (v/c), RELIG (v/c), AGE_CATEGORICAL (v/c), EDUC_CATEGORICAL\n| (v/c), TALKTO (v/n), SPOUSE (v/n), KIN (v/n), WEIGHT (e/n)\n+ edges from d2d7e9e (vertex names):\n[1] 1--2 1--3 1--4 2--3 2--4 3--4\n```\n\n\n:::\n:::\n\nNote that we would use  `as_network()` function if we wanted to construct networks in the network format. \n\nWe have a list of ego networks (in the igraph format), with each ego network in a different element in the list. We can see that the information on the alters was automatically passed to the igraph objects, as was the information on the weights for the alter-alter ties. Note that by default the igraph objects will not include ego. Ego is often (but not always) excluded from visualizations and calculations because ego is, by definition, tied to all alters. Including ego thus offers little additional structural information. We will consider measures below that incorporate both ego and alter information.\n\nAs with all igraph objects, we can extract useful information, like the attributes of the nodes. As an example, let's extract information on sex of alters from the first ego network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvertex_attr(ego_nets[[1]], \"SEX\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"male\"   \"female\" \"male\"   \"male\"   \"female\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Note that this is the same information as:\n# alter_dat[alter_dat$CASEID == 19850001, \"SEX\"]\n```\n:::\n\n\nNow let's plot a few networks focusing on the first 6 ego networks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# lapply() will perform a given function, here plot(), \n# over every element of an input list, here the first 6 elements of ego_nets.\n# note that you also can use purrr::walk()\npar(mfrow = c(2, 3))\nlapply(ego_nets[1:6], plot)\n```\n\n::: {.cell-output-display}\n![](05-ego-nets_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n\n## Descriptives on all ego nets\nNow that we have a list of networks, we can apply the same function to each network using a single line of code, again with the help of `lapply()`. \n\n### Exercise 3:\nFind the mean number of nodes and ties using `vcount()`  and `ecount()` function for all networks. Try reproducing the plots shown below. Hint: You can use `lapply()` again here.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](05-ego-nets_files/figure-html/exercise-plot-1.png){width=768}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# nodes\nnetwork_sizes <- lapply(ego_nets, vcount)\nnetwork_sizes <- unlist(network_sizes)\nmean(network_sizes, na.rm = T)\n\n# ties\nnetwork_edge_counts <- lapply(ego_nets, ecount)\nnetwork_edge_counts <- unlist(network_edge_counts)\nmean(network_edge_counts, na.rm = T)\n\n# Create data frames\ndf1 <- data.frame(NetworkSize = network_sizes)\ndf2 <- data.frame(EdgeCount = network_edge_counts)\n\n# Create histograms (ggplot approach)\np1 <- ggplot(df1, aes(x = NetworkSize)) +\n  geom_histogram(binwidth = 1, color = \"black\", fill = \"skyblue\") +\n  ggtitle(\"Histogram of Network Sizes\") +\n  xlab(\"# of Nodes\") +\n  theme_minimal()\n\np2 <- ggplot(df2, aes(x = EdgeCount)) +\n  geom_histogram(binwidth = 1, color = \"black\", fill = \"tan2\") +\n  ggtitle(\"Histogram of Edge Counts\") +\n  xlab(\"# of Edges\") +\n  theme_minimal()\n\np1 + p2 # needs patchwork\n```\n:::\n\n\n### Exercise 4:\nUse `edge_density` and apply to every ego network in the data to find the density of all networks. Create a histogram of these densities as in exercise 3.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\ndensities <- lapply(ego_nets, edge_density)\ndensities <- unlist(densities)\nhist(densities)\n```\n:::\n\n\n### Exercise 5:\nThere are also inbuilt functions in the `egor` package that can be used to analyze the ego networks, for example `ego_density`, `composition`, `alts_diversity_count`, `count_dyads`, and `comp_ei`. Explore these functions by yourself. Note that you then need to work with the egor object and not the igraph object.\n\n\n## Homophily: Ego-Alter Attributes\nThe EI index (External-Internal index) in ego network compositional analysis is a measure of homophily (similarity) or heterophily (difference) in ego networks. It tells you whether ego’s alters are more similar or dissimilar to the ego based on a categorical attribute (e.g., gender, ethnicity, etc.). The formula is given as: \n$$EI = \\frac{E - I}{E + I}$$\nwhere:\n\n  - E = Number of external ties (alters with a different attribute value than ego)\n  - I = Number of internal ties (alters with the same attribute value as ego)\n\nThe measure is interpreted as follows:\n\n  - +1: all alters are different from ego (maximum heterophily)\n  - 0: equal number of similar and different alters (neutral)\n  - –1: all alters are the same as ego (maximum homophily)\n\nLet's start by looking at the level of homophily based on the attribute `SEX`:\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp_ei(egonetlist, alt.attr = \"SEX\", ego.attr = \"SEX\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,531 × 2\n     .egoID    ei\n      <int> <dbl>\n 1 19850001  -0.2\n 2 19850002  -0.2\n 3 19850003  -1  \n 4 19850004   0.2\n 5 19850005   0.2\n 6 19850006  -0.5\n 7 19850007  -0.6\n 8 19850008   0.2\n 9 19850009   0  \n10 19850010  -1  \n# ℹ 1,521 more rows\n```\n\n\n:::\n:::\n\n\nFor each ego, you know have an index that tells you the level of homophily based on the attribute \"SEX\". For example, the first ego `19850001` tends to have slightly more homophilious ties compared to heterophilous ties. To get a better idea of this measure over all networks you can compute the proportion of negative/positive values or condition on (group by) another attribute. For example:\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp_ei(egonetlist, alt.attr = \"SEX\", ego.attr = \"SEX\") %>% count(ei < 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  `ei < 0`     n\n  <lgl>    <int>\n1 FALSE      599\n2 TRUE       795\n3 NA         137\n```\n\n\n:::\n:::\n\nNote that the NA's are cause because of some missing values in the alter data set.\n\n### Exercise 6:\nDo the same thing, but only consider ties that are based on variable `RACE`. What can you conclude?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\ncomp_ei(egonetlist, alt.attr = \"RACE\", ego.attr = \"RACE\")\n```\n:::\n\n\nHomphily based on `SEX` and `RACE` offers very different stories. We see that race is a much more salient dimension than gender, with many respondents matching perfectly with all members of their network along racial lines, but much less so with gender, where differences between ego and alter are more common.\n\n## Ego Networks as Predictors\nAbove we examined the properties of the ego networks, focusing mostly on racial and gender homophily. There are a number of other properties we could explore in more detail, like density or network size. For example, we might want to predict network size as a function of race, gender or other demographic characteristics.\n\nWe can also use properties of the ego networks as predictors of other outcomes of interest. For example, let's try and predict the variable `HAPPY` using the features of the ego networks. Are individuals with larger ego networks happier? \n\n`HAPPY` is coded as a 1 (very happy), 2 (pretty happy), 3 (not too happy). Let's add a label to the variable and reorder it to run from not happy to happy:\n\n::: {.cell}\n\n```{.r .cell-code}\nego_dat$HAPPY_FACTOR <- factor(ego_dat$HAPPY, levels = c(3, 2, 1), \n                            labels = c(\"not too happy\", \"pretty happy\", \n                                     \"very happy\"))\n```\n:::\n\n\nWe also turn our race and sex variables into factors. We set white as the first category in our race variable.\n\n::: {.cell}\n\n```{.r .cell-code}\nego_dat$RACE_FACTOR <- factor(ego_dat$RACE, levels = c(\"white\", \"asian\", \n                                                       \"black\", \"hispanic\", \n                                                       \"other\")) \nego_dat$SEX_FACTOR <- factor(ego_dat$SEX)\n```\n:::\n\n\nLet's also save density \n\n::: {.cell}\n\n```{.r .cell-code}\ndens <- ego_density(egonetlist)\nego_dat$DENSITY <- dens[[\"density\"]] #  getting values out of tibble format\n```\n:::\n\n\n`HAPPY` is an ordinal variable. With ordinal outcome variables, it is best to utilize ordered logistic regression (or a similar model). We will need the `polr()` function in the `MASS` package to run these models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'MASS'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:patchwork':\n\n    area\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:dplyr':\n\n    select\n```\n\n\n:::\n\n```{.r .cell-code}\ndens <- ego_density(egonetlist)\nego_dat$DENSITY <- dens[[\"density\"]] #  getting values out of tibble format\n```\n:::\n\nLet's create a data frame that has no missing data on any of the variables we want to include in the full model. The outcome of interest is `HAPPY_FACTOR` and the main predictors are ego network size (`NUMGIVEN`) and density (`DENSITY`) . We also include a number of demographic controls:\n\n::: {.cell}\n\n```{.r .cell-code}\nego_dat_nomiss <- na.omit(ego_dat[, c(\"HAPPY_FACTOR\", \"NUMGIVEN\", \"DENSITY\", \n                                     \"EDUC\", \"AGE\", \"RACE_FACTOR\", \n                                     \"SEX_FACTOR\")])\n```\n:::\n\n\nNow we run the ordered logistic regression predicting happiness. For our first model we will predict happiness as a function of our two structural network features, ego network size and density.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(happy_mod1 <- polr(HAPPY_FACTOR ~ NUMGIVEN + DENSITY, \n                           data = ego_dat_nomiss)) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nRe-fitting to get Hessian\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\npolr(formula = HAPPY_FACTOR ~ NUMGIVEN + DENSITY, data = ego_dat_nomiss)\n\nCoefficients:\n           Value Std. Error t value\nNUMGIVEN 0.08399    0.04753   1.767\nDENSITY  0.47660    0.20388   2.338\n\nIntercepts:\n                           Value   Std. Error t value\nnot too happy|pretty happy -1.4375  0.2700    -5.3240\npretty happy|very happy     1.5709  0.2697     5.8236\n\nResidual Deviance: 2105.42 \nAIC: 2113.42 \n```\n\n\n:::\n:::\n\n\nThe results suggest that respondents with dense networks report higher levels of happiness, while ego network size (`NUMGIVEN`) is not a significant predictor of happiness, controlling for density. The initial results would suggest that it is less about the number of people in your ego network that matters for happiness, and more about whether they know each other.\n\n### Exercise 7\nAdd the control variables into the model and interpret the results.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\nsummary(happy_mod2 <- polr(HAPPY_FACTOR ~ NUMGIVEN + DENSITY + EDUC + AGE + \n                             RACE_FACTOR + SEX_FACTOR, \n                           data = ego_dat_nomiss))\n```\n:::\n\nTo summarize the final model fit: density is still a significant predictor of happiness. \nIndividuals with alters who are interconnected consistently report higher levels of happiness, showing the potential benefits of being part of an integrated social group. \nWe also see that individuals with higher education tend to report higher levels of happiness, while those individuals identifying as black report lower levels of happiness. \n",
    "supporting": [
      "05-ego-nets_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}